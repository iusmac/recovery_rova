diff --git a/Android.bp b/Android.bp
index 86a1160..be9ca7f 100644
--- a/Android.bp
+++ b/Android.bp
@@ -12,6 +12,8 @@ cc_defaults {
         "-Wno-missing-field-initializers",
         "-Wno-unused-parameter",
         "-Wno-unused-variable",
+        "-Wno-macro-redefined",
+        "-DUSE_FSCRYPT_POLICY_V1=1"
     ],
 
     clang: true,
@@ -61,7 +63,6 @@ cc_defaults {
         "libincfs",
         "libhidlbase",
         "libkeyutils",
-        "liblog",
         "liblogwrap",
         "libselinux",
         "libsysutils",
@@ -111,16 +112,22 @@ cc_library_static {
         "vold_hw_fde_defaults",
         "vold_hw_fde_perf_defaults",
     ],
-
+    include_dirs: [
+        "system/core/gatekeeperd/include"
+    ],
     srcs: [
         "AppFuseUtil.cpp",
         "Benchmark.cpp",
         "Checkpoint.cpp",
+        "cryptfs.cpp",
         "CryptoType.cpp",
+        "Decrypt.cpp",
         "Devmapper.cpp",
         "EncryptInplace.cpp",
         "FileDeviceUtils.cpp",
         "FsCrypt.cpp",
+        "fscrypt_policy.cpp",
+        "HashPassword.cpp",
         "IdleMaint.cpp",
         "KeyBuffer.cpp",
         "KeyStorage.cpp",
@@ -138,7 +145,7 @@ cc_library_static {
         "VoldNativeServiceValidation.cpp",
         "VoldUtil.cpp",
         "VolumeManager.cpp",
-        "cryptfs.cpp",
+        "Weaver1.cpp",
         "fs/Exfat.cpp",
         "fs/Ext4.cpp",
         "fs/F2fs.cpp",
@@ -166,11 +173,29 @@ cc_library_static {
         },
     },
     shared_libs: [
+        "android.hardware.confirmationui@1.0",
+        "android.hardware.gatekeeper@1.0",
         "android.hardware.health.storage@1.0",
         "android.hardware.health.storage-V1-ndk_platform",
+        "android.hardware.keymaster@4.1",
+        "android.hardware.security.keymint-V1-ndk_platform",
+        "android.hardware.weaver@1.0",
+        "android.security.apc-ndk_platform",
         "android.system.keystore2-V1-ndk_platform",
+        "android.system.keystore2-V1-ndk_platform",
+        "android.security.authorization-ndk_platform",
         "android.security.maintenance-ndk_platform",
+        "libbinder",
         "libbinder_ndk",
+        "libgatekeeper",
+        "libgatekeeper_aidl",
+        "libhardware",
+        "libhidlbase",
+        "liblog",
+        "libchrome",
+        "libkeymaster4_1support",
+        "libkeystoreinfo",
+        "libkeystore-attestation-application-id",
         "libkeymint_support",
     ],
     whole_static_libs: [
@@ -304,3 +329,47 @@ filegroup {
     ],
     path: "binder",
 }
+
+cc_library {
+    name: "libkeystoreinfo",
+    host_supported: true,
+    cflags: [
+        "-Wno-unused-parameter",
+        "-Wno-unused-variable"
+    ],
+    include_dirs: [
+        "external/sqlite/dist/",
+        "system/vold"
+    ],
+    recovery_available: true,
+    srcs: [
+        "KeystoreInfo.cpp"
+    ],
+    shared_libs: [
+        "libsqlite"
+    ],
+    system_shared_libs: [
+        "libc", 
+        "libdl",
+        ],
+}
+
+cc_binary {
+    name: "fscryptpolicyget",
+    defaults: [
+        "vold_default_flags",
+        "vold_default_libs"
+    ],
+
+    srcs: ["fscryptpolicyget.cpp"],
+    static_libs: ["libvold"],
+
+    shared_libs: [
+        "android.hardware.health.storage@1.0",
+        "android.hardware.health.storage-V1-ndk_platform",
+        "android.system.keystore2-V1-ndk_platform",
+        "android.security.maintenance-ndk_platform",
+        "libbinder_ndk",
+        "libkeymint_support",
+    ]
+}
diff --git a/Decrypt.cpp b/Decrypt.cpp
new file mode 100755
index 0000000..28fc3cc
--- /dev/null
+++ b/Decrypt.cpp
@@ -0,0 +1,1008 @@
+/*
+ * Copyright (C) 2016 - 2020 The TeamWin Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "Decrypt.h"
+#include "FsCrypt.h"
+#include <fscrypt/fscrypt.h>
+
+#include <map>
+#include <string>
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <keyutils.h>
+#include "Weaver1.h"
+#include "cutils/properties.h"
+
+#include <openssl/sha.h>
+#include <openssl/aes.h>
+#include <openssl/evp.h>
+#include <openssl/rand.h>
+
+#include <dirent.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <fstream>
+#include <future>
+#include <algorithm>
+#include <chrono>
+
+#include <android/binder_manager.h>
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <base/threading/platform_thread.h>
+#include <android/hardware/confirmationui/1.0/types.h>
+#include <aidl/android/hardware/security/keymint/HardwareAuthToken.h>
+#include <aidl/android/security/authorization/IKeystoreAuthorization.h>
+#include <aidl/android/security/apc/BnConfirmationCallback.h>
+#include <aidl/android/system/keystore2/IKeystoreService.h>
+#include <aidl/android/system/keystore2/ResponseCode.h>
+#include <android/hardware/gatekeeper/1.0/IGatekeeper.h>
+
+#include <binder/IServiceManager.h>
+#include <binder/IPCThreadState.h>
+#include <hardware/hw_auth_token.h>
+
+#include <gatekeeper/GateKeeperResponse.h>
+
+#include <keystore/keystore.h>
+#include <keystore/keystore_client.h>
+#include <keystore/KeystoreResponse.h>
+#include <keystore/keystore_hidl_support.h>
+#include <keystore/keystore_return_types.h>
+#include <keystore/keymaster_types.h>
+#include <keymasterV4_1/Keymaster.h>
+#include <keystore/OperationResult.h>
+#include <keymint_support/authorization_set.h>
+#include <keymasterV4_1/keymaster_utils.h>
+
+extern "C" {
+#include "crypto_scrypt.h"
+}
+
+#include "fscrypt_policy.h"
+#include "fscrypt-common.h"
+#include "HashPassword.h"
+#include "KeystoreInfo.hpp"
+#include "KeyStorage.h"
+#include "android/os/IVold.h"
+
+namespace apc = ::aidl::android::security::apc;
+namespace keymint = ::aidl::android::hardware::security::keymint;
+namespace ks2 = ::aidl::android::system::keystore2;
+
+using ::aidl::android::hardware::security::keymint::HardwareAuthenticatorType;
+using ::aidl::android::hardware::security::keymint::HardwareAuthToken;
+using aidl::android::system::keystore2::IKeystoreService;
+using android::security::keymaster::OperationResult;
+using android::hardware::keymaster::V4_1::support::blob2hidlVec;
+using android::hardware::gatekeeper::V1_0::GatekeeperResponse;
+using GKResponse = ::android::service::gatekeeper::GateKeeperResponse;
+
+inline std::string hidlVec2String(const ::keystore::hidl_vec<uint8_t>& value) {
+    return std::string(reinterpret_cast<const std::string::value_type*>(&value[0]), value.size());
+}
+
+static bool lookup_ref_key_internal(std::map<userid_t, android::fscrypt::EncryptionPolicy> key_map, const uint8_t* policy, userid_t* user_id) {
+#ifdef USE_FSCRYPT_POLICY_V1
+	char policy_string_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	char key_map_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	bytes_to_hex(policy, FS_KEY_DESCRIPTOR_SIZE, policy_string_hex);
+#else
+	char policy_string_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	char key_map_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	bytes_to_hex(policy, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_string_hex);
+#endif
+
+    for (std::map<userid_t, android::fscrypt::EncryptionPolicy>::iterator it=key_map.begin(); it!=key_map.end(); ++it) {
+#ifdef USE_FSCRYPT_POLICY_V1
+		bytes_to_hex(reinterpret_cast<const uint8_t*>(&it->second.key_raw_ref[0]), FS_KEY_DESCRIPTOR_SIZE, key_map_hex);
+#else
+		bytes_to_hex(reinterpret_cast<const uint8_t*>(&it->second.key_raw_ref[0]), FSCRYPT_KEY_IDENTIFIER_SIZE, key_map_hex);
+#endif
+		std::string key_map_hex_string = std::string(key_map_hex);
+		if (key_map_hex_string == policy_string_hex) {
+            *user_id = it->first;
+            return true;
+        }
+    }
+    return false;
+}
+
+#ifdef USE_FSCRYPT_POLICY_V1
+extern "C" bool lookup_ref_key(fscrypt_policy_v1* fep, uint8_t* policy_type) {
+#else
+extern "C" bool lookup_ref_key(fscrypt_policy_v2* fep, uint8_t* policy_type) {
+#endif
+	userid_t user_id = 0;
+	std::string policy_type_string;
+
+#ifdef USE_FSCRYPT_POLICY_V1
+	char policy_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	bytes_to_hex(fep->master_key_descriptor, FS_KEY_DESCRIPTOR_SIZE, policy_hex);
+	if (std::strncmp((const char*)fep->master_key_descriptor, de_key_raw_ref.c_str(), FS_KEY_DESCRIPTOR_SIZE) == 0) {
+		policy_type_string = SYSTEM_DE_FSCRYPT_POLICY;
+		memcpy(policy_type, policy_type_string.data(), policy_type_string.size());
+		return true;
+	}
+    if (!lookup_ref_key_internal(s_de_policies, fep->master_key_descriptor, &user_id)) {
+        if (!lookup_ref_key_internal(s_ce_policies, fep->master_key_descriptor, &user_id)) {
+            return false;
+		} else {
+			policy_type_string = USER_CE_FSCRYPT_POLICY + std::to_string(user_id);
+		}
+    } else {
+			policy_type_string = USER_DE_FSCRYPT_POLICY + std::to_string(user_id);
+	}
+#else
+	char policy_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	bytes_to_hex(fep->master_key_identifier, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_hex);
+	if (std::strncmp((const char*)fep->master_key_identifier, de_key_raw_ref.c_str(), FSCRYPT_KEY_IDENTIFIER_SIZE) == 0) {
+		policy_type_string = SYSTEM_DE_FSCRYPT_POLICY;
+		memcpy(policy_type, policy_type_string.data(), policy_type_string.size());
+		return true;
+	}
+    if (!lookup_ref_key_internal(s_de_policies, fep->master_key_identifier, &user_id)) {
+        if (!lookup_ref_key_internal(s_ce_policies, fep->master_key_identifier, &user_id)) {
+            return false;
+		} else {
+			policy_type_string = USER_CE_FSCRYPT_POLICY + std::to_string(user_id);
+		}
+    } else {
+			policy_type_string = USER_DE_FSCRYPT_POLICY + std::to_string(user_id);
+	}
+#endif
+
+	memcpy(policy_type, policy_type_string.data(), policy_type_string.size());
+	printf("storing policy type: %s\n", policy_type);
+    return true;
+}
+
+extern "C" bool lookup_ref_tar(const uint8_t* policy_type, uint8_t* policy) {
+	std::string policy_type_string = std::string((char *) policy_type);
+#ifdef USE_FSCRYPT_POLICY_V1
+	char policy_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+	bytes_to_hex(policy_type, FS_KEY_DESCRIPTOR_SIZE, policy_hex);
+#else
+	char policy_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+	bytes_to_hex(policy_type, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_hex);
+#endif
+
+#ifdef USE_FSCRYPT_POLICY_V1
+	if (policy_type_string.substr(0,1) != FSCRYPT_V1) {
+#else
+	if (policy_type_string.substr(0,1) != FSCRYPT_V2) {
+#endif
+        printf("Unexpected version: %d\n", policy_type[0]);
+        return false;
+    }
+
+	if (policy_type_string.substr(1, 2) == SYSTEM_DE_KEY) {
+        memcpy(policy, de_key_raw_ref.data(), de_key_raw_ref.size());
+        return true;
+    }
+
+    std::string raw_ref;
+
+	if (policy_type_string.substr(1, 1) == USER_DE_KEY) {
+		userid_t user_id = std::stoi(policy_type_string.substr(3, 4).c_str());
+        if (lookup_key_ref(s_de_policies, user_id, &raw_ref)) {
+            memcpy(policy, raw_ref.data(), raw_ref.size());
+        } else
+            return false;
+    } else if (policy_type_string.substr(1, 1) == USER_CE_KEY) {
+		userid_t user_id = std::stoi(policy_type_string.substr(3, 4).c_str());
+        if (lookup_key_ref(s_ce_policies, user_id, &raw_ref)) {
+            memcpy(policy, raw_ref.data(), raw_ref.size());
+        } else
+            return false;
+    } else {
+        printf("unknown policy type: %s\n", policy_type);
+        return false;
+    }
+    return true;
+}
+
+extern "C" bool Decrypt_DE() {
+	printf("Attempting to initialize DE keys\n");
+	if (!fscrypt_initialize_systemwide_keys()) { // this deals with the overarching device encryption
+		printf("fscrypt_initialize_systemwide_keys returned fail\n");
+		return false;
+	}
+	if (!fscrypt_init_user0()) {
+		printf("fscrypt_init_user0 returned fail\n");
+		return false;
+	}
+	return true;
+}
+
+// Crappy functions for debugging, please ignore unless you need to debug
+// void output_hex(const std::string& in) {
+// 	const char *buf = in.data();
+// 	char hex[in.size() * 2 + 1];
+// 	unsigned int index;
+// 	for (index = 0; index < in.size(); index++)
+// 		sprintf(&hex[2 * index], "%02X", buf[index]);
+// }
+
+// void output_hex(const char* buf, const int size) {
+// 	char hex[size * 2 + 1];
+// 	int index;
+// 	for (index = 0; index < size; index++)
+// 		sprintf(&hex[2 * index], "%02X", buf[index]);
+// 	printf("%s", hex);
+// }
+
+// void output_hex(const unsigned char* buf, const int size) {
+// 	char hex[size * 2 + 1];
+// 	int index;
+// 	for (index = 0; index < size; index++)
+// 		sprintf(&hex[2 * index], "%02X", buf[index]);
+// 	printf("%s", hex);
+// }
+
+// void output_hex(std::vector<uint8_t>* vec) {
+// 	char hex[3];
+// 	unsigned int index;
+// 	for (index = 0; index < vec->size(); index++) {
+// 		sprintf(&hex[0], "%02X", vec->at(index));
+// 		printf("%s", hex);
+// 	}
+// }
+
+/* This is the structure of the data in the password data (*.pwd) file which the structure can be found
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#187 */
+struct password_data_struct {
+	int password_type;
+	unsigned char scryptN;
+	unsigned char scryptR;
+	unsigned char scryptP;
+	int salt_len;
+	void* salt;
+	int handle_len;
+	void* password_handle;
+};
+
+/* C++ replacement for
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#764 */
+bool Get_Password_Data(const std::string& spblob_path, const std::string& handle_str, password_data_struct *pwd) {
+	std::string pwd_file = spblob_path + handle_str + ".pwd";
+	std::string pwd_data;
+	if (android::vold::pathExists(pwd_file)) {
+		if (!android::base::ReadFileToString(pwd_file, &pwd_data)) {
+			printf("Failed to read '%s'\n", pwd_file.c_str());
+			return false;
+		}
+	} else {
+		printf("trying to read password data with leading 0\n");
+		pwd_file = spblob_path + "0" + handle_str + ".pwd";
+		if (!android::base::ReadFileToString(pwd_file, &pwd_data)) {
+			printf("Failed to read '%s'\n", pwd_file.c_str());
+			return false;
+		}	
+	}
+	// output_hex(pwd_data.data(), pwd_data.size());printf("\n");
+	const int* intptr = (const int*)pwd_data.data();
+	pwd->password_type = *intptr;
+	endianswap(&pwd->password_type);
+	//printf("password type %i\n", pwd->password_type); // 2 was PIN, 1 for pattern, 2 also for password, -1 for default password
+	const unsigned char* byteptr = (const unsigned char*)pwd_data.data() + sizeof(int);
+	pwd->scryptN = *byteptr;
+	byteptr++;
+	pwd->scryptR = *byteptr;
+	byteptr++;
+	pwd->scryptP = *byteptr;
+	byteptr++;
+	intptr = (const int*)byteptr;
+	pwd->salt_len = *intptr;
+	endianswap(&pwd->salt_len);
+	if (pwd->salt_len != 0) {
+		pwd->salt = malloc(pwd->salt_len);
+		if (!pwd->salt) {
+			printf("Get_Password_Data malloc salt\n");
+			return false;
+		}
+		memcpy(pwd->salt, intptr + 1, pwd->salt_len);
+		intptr++;
+		byteptr = (const unsigned char*)intptr;
+		byteptr += pwd->salt_len;
+	} else {
+		printf("Get_Password_Data salt_len is 0\n");
+		return false;
+	}
+	intptr = (const int*)byteptr;
+	pwd->handle_len = *intptr;
+	endianswap(&pwd->handle_len);
+	if (pwd->handle_len != 0) {
+		pwd->password_handle = malloc(pwd->handle_len);
+		if (!pwd->password_handle) {
+			printf("Get_Password_Data malloc password_handle\n");
+			return false;
+		}
+		memcpy(pwd->password_handle, intptr + 1, pwd->handle_len);
+	} else {
+		printf("Get_Password_Data handle_len is 0\n");
+		// Not an error if using weaver
+	}
+	return true;
+}
+
+/* C++ replacement for
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#765
+ * called here
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#1050 */
+bool Get_Password_Token(const password_data_struct *pwd, const std::string& Password, unsigned char* password_token) {
+	if (!password_token) {
+		printf("password_token is null\n");
+		return false;
+	}
+	unsigned int N = 1 << pwd->scryptN;
+	unsigned int r = 1 << pwd->scryptR;
+	unsigned int p = 1 << pwd->scryptP;
+	//printf("N %i r %i p %i\n", N, r, p);
+	int ret = crypto_scrypt(reinterpret_cast<const uint8_t*>(Password.data()), Password.size(),
+                          reinterpret_cast<const uint8_t*>(pwd->salt), pwd->salt_len,
+                          N, r, p,
+                          password_token, 32);
+	if (ret != 0) {
+		printf("scrypt error\n");
+		return false;
+	}
+	return true;
+}
+
+// Data structure for the *.weaver file, see Get_Weaver_Data below
+struct weaver_data_struct {
+	unsigned char version;
+	int slot;
+};
+
+/* C++ replacement for
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#501
+ * called here
+ * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#768 */
+bool Get_Weaver_Data(const std::string& spblob_path, const std::string& handle_str, weaver_data_struct *wd) {
+	printf("Get_Weaver_Data\n");
+	std::string weaver_file = spblob_path + handle_str + ".weaver";
+	std::string weaver_data;
+	if (!android::base::ReadFileToString(weaver_file, &weaver_data)) {
+		printf("Failed to read '%s'\n", weaver_file.c_str());
+		return false;
+	}
+	// output_hex(weaver_data.data(), weaver_data.size());printf("\n");
+	const unsigned char* byteptr = (const unsigned char*)weaver_data.data();
+	wd->version = *byteptr;
+	// printf("weaver version %i\n", wd->version);
+	const int* intptr = (const int*)weaver_data.data() + sizeof(unsigned char);
+	wd->slot = *intptr;
+	//endianswap(&wd->slot); not needed
+	// printf("weaver slot %i\n", wd->slot);
+	return true;
+}
+
+namespace android {
+
+/* These next 2 functions try to get the keystore service 50 times because
+ * the keystore is not always ready when TWRP boots */
+android::sp<IBinder> getKeystoreBinder() {
+	android::sp<IServiceManager> sm = android::defaultServiceManager();
+    return sm->getService(String16("android.security.keystore"));
+}
+
+android::sp<IBinder> getKeystoreBinderRetry() {
+	printf("Starting keystore...\n");
+    property_set("ctl.start", "keystore");
+	int retry_count = 50;
+	android::sp<IBinder> binder = getKeystoreBinder();
+	while (binder == NULL && retry_count) {
+		printf("Waiting for keystore service... %i\n", retry_count--);
+		sleep(1);
+		binder = getKeystoreBinder();
+	}
+	return binder;
+}
+
+namespace keystore {
+
+#define SYNTHETIC_PASSWORD_VERSION_V1 1
+#define SYNTHETIC_PASSWORD_VERSION_V2 2
+#define SYNTHETIC_PASSWORD_VERSION_V3 3
+#define SYNTHETIC_PASSWORD_PASSWORD_BASED 0
+#define SYNTHETIC_PASSWORD_KEY_PREFIX "USRSKEY_synthetic_password_"
+#define USR_PRIVATE_KEY_PREFIX "USRPKEY_synthetic_password_"
+#define PASSWORD_TOKEN_SIZE 32
+#define GK_ERROR *gkResponse = GKResponse::error(), Status::ok()
+
+	ks2::KeyDescriptor keyDescriptor(const std::string& alias) {
+		return {
+			.domain = ks2::Domain::SELINUX,
+			.nspace = NAMESPACE_LOCKSETTINGS,
+			.alias = alias,
+			.blob = {},
+		};
+	}
+
+	int unwrapError(const ndk::ScopedAStatus& status) {
+		if (status.isOk()) return 0;
+		if (status.getExceptionCode() == EX_SERVICE_SPECIFIC) {
+			return status.getServiceSpecificError();
+		} else {
+			return static_cast<int>(ks2::ResponseCode::SYSTEM_ERROR);
+		}
+	}
+
+	void copySqliteDb() {
+		std::string keystore_path = "/tmp/misc/keystore/";
+		std::string dst = keystore_path + "persistent.sqlite";
+		std::string src = "/data/misc/keystore/persistent.sqlite";
+		std::ifstream srcif(src.c_str(), std::ios::binary);
+		std::ofstream dstof(dst.c_str(), std::ios::binary);
+		printf("copying '%s' to '%s'\n", src.c_str(), dst.c_str());
+		dstof << srcif.rdbuf();
+		srcif.close();
+		dstof.close();
+	}
+
+	/* C++ replacement for function of the same name
+	* https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#867
+	* returning an empty string indicates an error */
+	std::string unwrapSyntheticPasswordBlob(const std::string& spblob_path, const std::string& handle_str, const userid_t user_id,
+		const void* application_id, const size_t application_id_size, uint32_t auth_token_len) {
+		printf("Attempting to unwrap synthetic password blob\n");
+		std::string disk_decryption_secret_key = "";
+
+		android::ProcessState::self()->startThreadPool();
+
+		// Read the data from the .spblob file per: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#869
+		std::string spblob_file = spblob_path + handle_str + ".spblob";
+		std::string spblob_data;
+		if (!android::base::ReadFileToString(spblob_file, &spblob_data)) {
+			printf("Failed to read '%s'\n", spblob_file.c_str());
+			return disk_decryption_secret_key;
+		}
+		unsigned char* byteptr = (unsigned char*)spblob_data.data();
+		if (*byteptr != SYNTHETIC_PASSWORD_VERSION_V2 && *byteptr != SYNTHETIC_PASSWORD_VERSION_V1
+				&& *byteptr != SYNTHETIC_PASSWORD_VERSION_V3) {
+			printf("Unsupported synthetic password version %i\n", *byteptr);
+			return disk_decryption_secret_key;
+		}
+		const unsigned char* synthetic_password_version = byteptr;
+		byteptr++;
+		if (*byteptr != SYNTHETIC_PASSWORD_PASSWORD_BASED) {
+			printf("spblob data is not SYNTHETIC_PASSWORD_PASSWORD_BASED\n");
+			return disk_decryption_secret_key;
+		}
+		byteptr++; // Now we're pointing to the blob data itself
+		if (*synthetic_password_version == SYNTHETIC_PASSWORD_VERSION_V2
+				|| *synthetic_password_version == SYNTHETIC_PASSWORD_VERSION_V3) {
+			printf("spblob v2 / v3\n");
+			/* Version 2 / 3 of the spblob is basically the same as version 1, but the order of getting the intermediate key and disk decryption key have been flip-flopped
+			* as seen in https://android.googlesource.com/platform/frameworks/base/+/5025791ac6d1538224e19189397de8d71dcb1a12
+			*/
+			/* First decrypt call found in
+			* https://android.googlesource.com/platform/frameworks/base/+/android-8.1.0_r18/services/core/java/com/android/server/locksettings/SyntheticPasswordCrypto.java#135
+			* We will use https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreCipherSpiBase.java
+			* and https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreAuthenticatedAESCipherSpi.java
+			* First we set some algorithm parameters as seen in two places:
+			* https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreAuthenticatedAESCipherSpi.java#297
+			* https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/keystore/java/android/security/keystore/AndroidKeyStoreAuthenticatedAESCipherSpi.java#216 */
+			// When using secdis (aka not weaver) you must supply an auth token to the keystore prior to the begin operation
+			int32_t ret;
+			size_t maclen = 128;
+			unsigned char* iv = (unsigned char*)byteptr; // The IV is the first 12 bytes of the spblob
+			::keystore::hidl_vec<uint8_t> iv_hidlvec;
+			iv_hidlvec.setToExternal((unsigned char*)byteptr, 12);
+			// printf("iv: "); output_hex((const unsigned char*)iv, 12); printf("\n");
+
+			KeystoreInfo keystore_info;
+			std::string handle = keystore_info.getHandle(user_id);
+			std::string keystore_alias = keystore_info.getAlias(handle);
+			int32_t error_code;
+			unsigned char* cipher_text = (unsigned char*)byteptr + 12; // The cipher text comes immediately after the IV
+			std::string cipher_text_str(byteptr, byteptr + spblob_data.size() - 14);
+			::keystore::hidl_vec<uint8_t> cipher_text_hidlvec;
+
+			cipher_text_hidlvec.setToExternal(cipher_text, spblob_data.size() - 14 /* 1 each for version and SYNTHETIC_PASSWORD_PASSWORD_BASED and 12 for the iv */);
+			auto begin_params = keymint::AuthorizationSetBuilder()
+				.Authorization(keymint::TAG_ALGORITHM, ::keymint::Algorithm::AES)
+				.Authorization(::keymint::TAG_BLOCK_MODE, ::keymint::BlockMode::GCM)
+				.Padding(::keymint::PaddingMode::NONE)
+				.Authorization(keymint::TAG_PURPOSE, keymint::KeyPurpose::DECRYPT)
+				.Authorization(::keymint::TAG_NONCE, iv_hidlvec)
+				.Authorization(::keymint::TAG_MAC_LENGTH, maclen);
+
+			ks2::KeyEntryResponse keyEntryResponse;
+			::ndk::SpAIBinder keystoreBinder(AServiceManager_checkService("android.system.keystore2.IKeystoreService/default"));
+			auto keystore = ks2::IKeystoreService::fromBinder(keystoreBinder);
+			auto rc = keystore->getKeyEntry(keyDescriptor(keystore_alias), &keyEntryResponse);
+			if (!rc.isOk()) {
+				auto error = unwrapError(rc);
+				if (ks2::ResponseCode(error) == ks2::ResponseCode::KEY_NOT_FOUND) {
+					printf("key not found\n");
+				} else {
+					printf("Failed to get key entry: %s\n", rc.getDescription().c_str());
+				}
+				return disk_decryption_secret_key;
+			}
+			std::variant<int, ks2::KeyEntryResponse> response = keyEntryResponse;
+			auto keyResponse = std::get<ks2::KeyEntryResponse>(response);
+			ks2::CreateOperationResponse encOperationResponse;
+			auto begin_rc = keyResponse.iSecurityLevel->createOperation(
+				keyResponse.metadata.key, begin_params.vector_data(), true,
+				&encOperationResponse);
+			if (!begin_rc.isOk()) {
+				printf("Begin Operation failed\n");
+				return disk_decryption_secret_key;
+			}
+			std::optional<std::vector<uint8_t>> optPlaintext;
+
+			begin_rc = encOperationResponse.iOperation->finish(cipher_text_hidlvec, {}, &optPlaintext);
+			if (!begin_rc.isOk()) {
+				printf("finish reponse failed");
+				return disk_decryption_secret_key;
+			}
+
+			size_t keystore_result_size = optPlaintext->size();
+			unsigned char* keystore_result = (unsigned char*)malloc(keystore_result_size);
+			if (!keystore_result) {
+				printf("malloc on keystore_result\n");
+				return disk_decryption_secret_key;
+			}
+			memcpy(keystore_result, &optPlaintext->front(), keystore_result_size);
+
+			const unsigned char* intermediate_iv = keystore_result;
+			// printf("intermediate_iv: "); output_hex((const unsigned char*)intermediate_iv, 12); printf("\n");
+			const unsigned char* intermediate_cipher_text = (const unsigned char*)keystore_result + 12; // The cipher text comes immediately after the IV
+			int cipher_size = keystore_result_size - 12;
+			// First we personalize as seen https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordCrypto.java#102
+			void* personalized_application_id = PersonalizedHashBinary(PERSONALISATION_APPLICATION_ID, (const char*)application_id, application_id_size);
+			if (!personalized_application_id) {
+				printf("Unable to obtain personalized_application_id\n");
+				return disk_decryption_secret_key;
+			}
+			// printf("personalized application id: "); output_hex((unsigned char*)personalized_application_id, SHA512_DIGEST_LENGTH); printf("\n");
+			// Now we'll decrypt using openssl AES/GCM/NoPadding
+			OpenSSL_add_all_ciphers();
+			int actual_size=0, final_size=0;
+			EVP_CIPHER_CTX *d_ctx = EVP_CIPHER_CTX_new();
+			const unsigned char* key = (const unsigned char*)personalized_application_id; // The key is the now personalized copy of the application ID
+			// printf("key: "); output_hex((const unsigned char*)key, 32); printf("\n");
+			EVP_DecryptInit(d_ctx, EVP_aes_256_gcm(), key, intermediate_iv);
+			unsigned char* secret_key = (unsigned char*)malloc(cipher_size);
+			if (!secret_key) {
+				printf("malloc failure on secret key\n");
+				return disk_decryption_secret_key;
+			}
+			EVP_DecryptUpdate(d_ctx, secret_key, &actual_size, intermediate_cipher_text, cipher_size);
+			unsigned char tag[AES_BLOCK_SIZE];
+			EVP_CIPHER_CTX_ctrl(d_ctx, EVP_CTRL_GCM_SET_TAG, 16, tag);
+			EVP_DecryptFinal_ex(d_ctx, secret_key + actual_size, &final_size);
+			EVP_CIPHER_CTX_free(d_ctx);
+			free(personalized_application_id);
+			free(keystore_result);
+			int secret_key_real_size = actual_size - 16;
+			// printf("secret key:  "); output_hex((const unsigned char*)secret_key, secret_key_real_size); printf("\n");
+			// The payload data from the keystore update is further personalized at https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#153
+			// We now have the disk decryption key!
+			if (*synthetic_password_version == SYNTHETIC_PASSWORD_VERSION_V3) {
+				// V3 uses SP800 instead of SHA512
+				disk_decryption_secret_key = PersonalizedHashSP800(PERSONALIZATION_FBE_KEY, PERSONALISATION_CONTEXT, (const char*)secret_key, secret_key_real_size);
+			} else {
+				disk_decryption_secret_key = PersonalizedHash(PERSONALIZATION_FBE_KEY, (const char*)secret_key, secret_key_real_size);
+			}
+			// printf("disk_decryption_secret_key: '%s'\n", disk_decryption_secret_key.c_str());
+			free(secret_key);
+			return disk_decryption_secret_key;
+		}
+		return disk_decryption_secret_key;
+	}
+}
+// /* C++ replacement for
+//  * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#992
+//  * called here
+//  * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#813 */
+bool Get_Secdis(const std::string& spblob_path, const std::string& handle_str, std::string& secdis_data) {
+	std::string secdis_file = spblob_path + handle_str + ".secdis";
+	if (!android::base::ReadFileToString(secdis_file, &secdis_data)) {
+		printf("Failed to read '%s'\n", secdis_file.c_str());
+		return false;
+	}
+	// output_hex(secdis_data.data(), secdis_data.size());printf("\n");
+	return true;
+}
+
+// // C++ replacement for https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#1033
+userid_t fakeUid(const userid_t uid) {
+    return 100000 + uid;
+}
+
+bool Is_Weaver(const std::string& spblob_path, const std::string& handle_str) {
+	printf("Is_Weaver\n");
+	std::string weaver_file = spblob_path + handle_str + ".weaver";
+	struct stat st;
+	if (stat(weaver_file.c_str(), &st) == 0)
+		return true;
+	return false;
+}
+
+bool Free_Return(bool retval, void* weaver_key, password_data_struct* pwd) {
+	printf("Free_Return\n");
+	if (weaver_key)
+		free(weaver_key);
+	if (pwd->salt)
+		free(pwd->salt);
+	if (pwd->password_handle)
+		free(pwd->password_handle);
+	return retval;
+}
+
+// /* Decrypt_User_Synth_Pass is the TWRP C++ equivalent to spBasedDoVerifyCredential
+//  * https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/LockSettingsService.java#1998 */
+bool Decrypt_User_Synth_Pass(const userid_t user_id, const std::string& Password) {
+	printf("Attempting to decrypt user's synthetic password\n");
+	bool retval = false;
+	void* weaver_key = NULL;
+	password_data_struct pwd;
+	pwd.salt = NULL;
+	pwd.salt_len = 0;
+	pwd.password_handle = NULL;
+	pwd.handle_len = 0;
+	char application_id[PASSWORD_TOKEN_SIZE + SHA512_DIGEST_LENGTH];
+
+    uint32_t auth_token_len = 0;
+
+	std::string secret; // this will be the disk decryption key that is sent to vold
+	int token = 0; // there is no token used for this kind of decrypt, key escrow is handled by weaver
+	int flags = android::os::IVold::STORAGE_FLAG_CE;
+	char spblob_path_char[PATH_MAX];
+	sprintf(spblob_path_char, "/data/system_de/%d/spblob/", user_id);
+	std::string spblob_path = spblob_path_char;
+	long handle = 0;
+	// Get the handle: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/LockSettingsService.java#2017
+	KeystoreInfo keystore_info;
+	std::string handle_str = keystore_info.getHandle(user_id);
+	// Now we begin driving unwrapPasswordBasedSyntheticPassword from: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#758
+	// First we read the password data which contains scrypt parameters
+	if (!Get_Password_Data(spblob_path, handle_str, &pwd)) {
+		printf("Failed to Get_Password_Data\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+	// printf("pwd N %i R %i P %i salt ", pwd.scryptN, pwd.scryptR, pwd.scryptP); output_hex((char*)pwd.salt, pwd.salt_len); printf("\n");
+	unsigned char password_token[PASSWORD_TOKEN_SIZE];
+	// printf("Password: '%s'\n", Password.c_str());
+	// The password token is the password scrypted with the parameters from the password data file
+	printf("fscrypt::GetPassword_Token\n");
+	if (!Get_Password_Token(&pwd, Password, &password_token[0])) {
+		printf("Failed to Get_Password_Token\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+	// output_hex(&password_token[0], PASSWORD_TOKEN_SIZE);printf("\n");
+	if (Is_Weaver(spblob_path, handle_str)) {
+		printf("using weaver\n");
+		// BEGIN PIXEL 2 WEAVER
+		// Get the weaver data from the .weaver file which tells us which slot to use when we ask weaver for the escrowed key
+		// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#768
+		weaver_data_struct wd;
+		if (!Get_Weaver_Data(spblob_path, handle_str, &wd)) {
+			printf("Failed to get weaver data\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// The weaver key is the the password token prefixed with "weaver-key" padded to 128 with nulls with the password token appended then SHA512
+		// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#1059
+		weaver_key = PersonalizedHashBinary(PERSONALISATION_WEAVER_KEY, (char*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		if (!weaver_key) {
+			printf("malloc error getting weaver_key\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// Now we start driving weaverVerify: https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#343
+		// Called from https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#776
+		android::vold::Weaver weaver;
+		if (!weaver) {
+			printf("Failed to get weaver service\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// Get the key size from weaver service
+		uint32_t weaver_key_size = 0;
+		if (!weaver.GetKeySize(&weaver_key_size)) {
+			printf("Failed to get weaver key size\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		} else {
+			printf("weaver key size is %u\n", weaver_key_size);
+		}
+		// printf("weaver key: "); output_hex((unsigned char*)weaver_key, weaver_key_size); printf("\n");
+		// Send the slot from the .weaver file, the computed weaver key, and get the escrowed key data
+		std::vector<uint8_t> weaver_payload;
+		// TODO: we should return more information about the status including time delays before the next retry
+		if (!weaver.WeaverVerify(wd.slot, weaver_key, &weaver_payload)) {
+			printf("failed to weaver verify\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		// printf("weaver payload: "); output_hex(&weaver_payload); printf("\n");
+		// Done with weaverVerify
+		// Now we will compute the application ID
+		// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#964
+		// Called from https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#780
+		// The escrowed weaver key data is prefixed with "weaver-pwd" padded to 128 with nulls with the weaver payload appended then SHA512
+		void* weaver_secret = PersonalizedHashBinary(PERSONALISATION_WEAVER_PASSWORD, (const char*)weaver_payload.data(), weaver_payload.size());
+		// printf("weaver secret: "); output_hex((unsigned char*)weaver_secret, SHA512_DIGEST_LENGTH); printf("\n");
+		// The application ID is the password token and weaver secret appended to each other
+		memcpy((void*)&application_id[0], (void*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		memcpy((void*)&application_id[PASSWORD_TOKEN_SIZE], weaver_secret, SHA512_DIGEST_LENGTH);
+		// printf("application ID: "); output_hex((unsigned char*)application_id, PASSWORD_TOKEN_SIZE + SHA512_DIGEST_LENGTH); printf("\n");
+		// END PIXEL 2 WEAVER
+	} else {
+		printf("using secdis to decrypt spblob\n");
+		std::string secdis_data;
+		if (!Get_Secdis(spblob_path, handle_str, secdis_data)) {
+			printf("Failed to get secdis data\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		void* secdiscardable = PersonalizedHashBinary(PERSONALISATION_SECDISCARDABLE, (char*)secdis_data.data(), secdis_data.size());
+		if (!secdiscardable) {
+			printf("malloc error getting secdiscardable\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		memcpy((void*)&application_id[0], (void*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		memcpy((void*)&application_id[PASSWORD_TOKEN_SIZE], secdiscardable, SHA512_DIGEST_LENGTH);
+
+		int ret = -1;
+		bool request_reenroll = false;
+		android::sp<android::hardware::gatekeeper::V1_0::IGatekeeper> gk_device;
+		gk_device = ::android::hardware::gatekeeper::V1_0::IGatekeeper::getService();
+		if (gk_device == nullptr) {
+			printf("failed to get gatekeeper service\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		if (pwd.handle_len <= 0) {
+			printf("no password handle supplied\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		android::hardware::hidl_vec<uint8_t> pwd_handle_hidl;
+		pwd_handle_hidl.setToExternal(const_cast<uint8_t *>((const uint8_t *)pwd.password_handle), pwd.handle_len);
+		void* gk_pwd_token = PersonalizedHashBinary(PERSONALIZATION_USER_GK_AUTH, (char*)&password_token[0], PASSWORD_TOKEN_SIZE);
+		if (!gk_pwd_token) {
+			printf("malloc error getting gatekeeper_key\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+		android::hardware::hidl_vec<uint8_t> gk_pwd_token_hidl;
+		GKResponse gkResponse;
+		gk_pwd_token_hidl.setToExternal(const_cast<uint8_t *>((const uint8_t *)gk_pwd_token), SHA512_DIGEST_LENGTH);
+		android::hardware::Return<void> hwRet =
+			gk_device->verify(fakeUid(user_id), 0 /* challenge */,
+							  pwd_handle_hidl,
+							  gk_pwd_token_hidl,
+							  [&gkResponse]
+								// []
+								(const android::hardware::gatekeeper::V1_0::GatekeeperResponse &rsp) {
+									// ret = static_cast<int>(rsp.code); // propagate errors
+									if (rsp.code >= android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::STATUS_OK) {
+										gkResponse = GKResponse::ok({rsp.data.begin(), rsp.data.end()});
+										const hw_auth_token_t* hwAuthToken =
+											reinterpret_cast<const hw_auth_token_t*>(gkResponse.payload().data());
+										HardwareAuthToken authToken;
+										authToken.timestamp.milliSeconds = betoh64(hwAuthToken->timestamp);
+										authToken.challenge = hwAuthToken->challenge;
+										authToken.userId = hwAuthToken->user_id;
+										authToken.authenticatorId = hwAuthToken->authenticator_id;
+										authToken.authenticatorType = static_cast<HardwareAuthenticatorType>(
+												betoh32(hwAuthToken->authenticator_type));
+										authToken.mac.assign(&hwAuthToken->hmac[0], &hwAuthToken->hmac[32]);
+										AIBinder* authzAIBinder = AServiceManager_getService("android.security.authorization");
+										::ndk::SpAIBinder binder(authzAIBinder);
+										auto service = aidl::android::security::authorization::IKeystoreAuthorization::fromBinder(binder);
+										if (service == NULL) {
+											printf("error: could not connect to keystore service\n");
+											ALOGE("error: could not connect to keystore service\n");
+										}
+										auto binder_result = service->addAuthToken(authToken);
+									}
+								}
+							 );
+		free(gk_pwd_token);
+		if (!hwRet.isOk()) {
+			printf("gatekeeper verification failed\n");
+			return Free_Return(retval, weaver_key, &pwd);
+		}
+	}
+	// Now we will handle https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#816
+	// Plus we will include the last bit that computes the disk decrypt key found in:
+	// https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r23/services/core/java/com/android/server/locksettings/SyntheticPasswordManager.java#153
+	secret = android::keystore::unwrapSyntheticPasswordBlob(spblob_path, handle_str, user_id, (const void*)&application_id[0], 
+		PASSWORD_TOKEN_SIZE + SHA512_DIGEST_LENGTH, auth_token_len);
+	if (!secret.size()) {
+		printf("failed to unwrapSyntheticPasswordBlob\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+
+	printf("Attempting to unlock user storage\n");
+	if (!fscrypt_unlock_user_key(user_id, token, secret)) {
+		printf("fscrypt_unlock_user_key returned fail\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+
+	printf("Attempting to prepare user storage\n");
+
+	if (!fscrypt_prepare_user_storage("", user_id, 0, flags)) {
+		printf("failed to fscrypt_prepare_user_storage\n");
+		return Free_Return(retval, weaver_key, &pwd);
+	}
+	printf("User %i Decrypted Successfully!\n", user_id);
+	retval = true;
+	return Free_Return(retval, weaver_key, &pwd);
+}
+
+extern "C" int Get_Password_Type(const userid_t user_id, std::string& filename) {
+	struct stat st;
+	char spblob_path_char[PATH_MAX];
+	sprintf(spblob_path_char, "/data/system_de/%d/spblob/", user_id);
+	if (stat(spblob_path_char, &st) == 0) {
+		std::string spblob_path = spblob_path_char;
+		KeystoreInfo keystore_info;
+		std::string handle_str = keystore_info.getHandle(user_id);
+		printf("Handle is '%s'\n", handle_str.c_str());
+		password_data_struct pwd;
+		if (!Get_Password_Data(spblob_path, handle_str, &pwd)) {
+			printf("Failed to Get_Password_Data\n");
+			return 0;
+		}
+		// In Android type 1 is pattern
+		// In Android <11 type 2 is PIN or password
+		// In Android 11+ type 3 is PIN and type 4 is password
+		if (pwd.password_type == 2) {
+			printf("password type: password/PIN\n");
+			return 1; // In TWRP this means password or PIN (Android <11)
+		} else if (pwd.password_type == 4) {
+			printf("password type: password\n");
+			return 1; // In TWRP this means password
+		} else if (pwd.password_type == 1) {
+			printf("password type: pattern\n");
+			return 2; // In TWRP this means pattern
+		} else if (pwd.password_type == 3) {
+			printf("password type: PIN\n");
+			return 3; // In TWRP this means PIN
+		}
+		printf("using default password\n");
+		return 0; // We'll try the default password
+	}
+	std::string path;
+    if (user_id == 0) {
+		path = "/data/system/";
+	} else {
+		char user_id_str[5];
+		sprintf(user_id_str, "%i", user_id);	
+		path = "/data/system/users/";
+		path += user_id_str;
+		path += "/";
+	}
+	filename = path + "gatekeeper.password.key";
+	if (stat(filename.c_str(), &st) == 0 && st.st_size > 0)
+		return 1;
+	filename = path + "gatekeeper.pattern.key";
+	if (stat(filename.c_str(), &st) == 0 && st.st_size > 0)
+		return 2;
+	printf("Unable to locate gatekeeper password file '%s'\n", filename.c_str());
+	filename = "";
+	return 0;
+}
+
+extern "C" bool Decrypt_User(const userid_t user_id, const std::string& Password) {
+	printf("Attempting to decrypt user\n");
+    uint8_t *auth_token;
+    uint32_t auth_token_len;
+    int ret;
+
+    struct stat st;
+    if (user_id > 9999) {
+		printf("user_id is too big\n");
+		return false;
+	}
+    std::string filename;
+    bool Default_Password = (Password == "!");
+    if (Get_Password_Type(user_id, filename) == 0 && !Default_Password) {
+		printf("Unknown password type\n");
+		return false;
+	}
+
+	int flags = android::os::IVold::STORAGE_FLAG_CE;
+
+	if (Default_Password) {
+		if (!fscrypt_unlock_user_key(user_id, 0, "!")) {
+			printf("unlock_user_key returned fail\n");
+			return false;
+		}
+		printf("Attempting to prepare user storage\n");
+		if (!fscrypt_prepare_user_storage("", user_id, 0, flags)) {
+			printf("failed to fscrypt_prepare_user_storage\n");
+			return false;
+		}
+		printf("User %i Decrypted Successfully!\n", user_id);
+		return true;
+	}
+	if (stat("/data/system_de/0/spblob", &st) == 0) {
+		printf("Using synthetic password method\n");
+		return Decrypt_User_Synth_Pass(user_id, Password);
+	}
+	// printf("password filename is '%s'\n", filename.c_str());
+	if (stat(filename.c_str(), &st) != 0) {
+		printf("error stat'ing key file: %s\n", strerror(errno));
+		return false;
+	}
+	std::string handle;
+    if (!android::base::ReadFileToString(filename, &handle)) {
+		printf("Failed to read '%s'\n", filename.c_str());
+		return false;
+	}
+    bool should_reenroll;
+	bool request_reenroll = false;
+	android::sp<android::hardware::gatekeeper::V1_0::IGatekeeper> gk_device;
+	gk_device = ::android::hardware::gatekeeper::V1_0::IGatekeeper::getService();
+	if (gk_device == nullptr)
+		return false;
+	android::hardware::hidl_vec<uint8_t> curPwdHandle;
+	curPwdHandle.setToExternal(const_cast<uint8_t *>((const uint8_t *)handle.c_str()), st.st_size);
+	android::hardware::hidl_vec<uint8_t> enteredPwd;
+	enteredPwd.setToExternal(const_cast<uint8_t *>((const uint8_t *)Password.c_str()), Password.size());
+
+	android::hardware::Return<void> hwRet =
+		gk_device->verify(user_id, 0 /* challange */,
+						  curPwdHandle,
+						  enteredPwd,
+						  [&ret, &request_reenroll, &auth_token, &auth_token_len]
+							(const android::hardware::gatekeeper::V1_0::GatekeeperResponse &rsp) {
+								ret = static_cast<int>(rsp.code); // propagate errors
+								if (rsp.code >= android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::STATUS_OK) {
+									auth_token = new uint8_t[rsp.data.size()];
+									auth_token_len = rsp.data.size();
+									memcpy(auth_token, rsp.data.data(), auth_token_len);
+									request_reenroll = (rsp.code == android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::STATUS_REENROLL);
+									ret = 0; // all success states are reported as 0
+								} else if (rsp.code == android::hardware::gatekeeper::V1_0::GatekeeperStatusCode::ERROR_RETRY_TIMEOUT && rsp.timeout > 0) {
+									ret = rsp.timeout;
+								}
+							}
+						 );
+	if (!hwRet.isOk()) {
+		return false;
+	}
+
+	char token_hex[(auth_token_len*2)+1];
+	token_hex[(auth_token_len*2)] = 0;
+	uint32_t i;
+	for (i=0;i<auth_token_len;i++) {
+		sprintf(&token_hex[2*i], "%02X", auth_token[i]);
+	}
+	// The secret is "Android FBE credential hash" plus appended 0x00 to reach 128 bytes then append the user's password then feed that to sha512sum
+	std::string secret = HashPassword(Password);
+	if (!fscrypt_unlock_user_key(user_id, 0, secret)) {
+		printf("fscrypt_unlock_user_key returned fail\n");
+		return false;
+	}
+
+	printf("Attempting to prepare user storage\n");
+	if (!fscrypt_prepare_user_storage("", user_id, 0, flags)) {
+		printf("failed to fscrypt_prepare_user_storage\n");
+		return false;
+	}
+	printf("User %i Decrypted Successfully!\n", user_id);
+	return true;
+}
+}
diff --git a/Decrypt.h b/Decrypt.h
new file mode 100755
index 0000000..ff926dc
--- /dev/null
+++ b/Decrypt.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdbool.h>
+#include <sys/cdefs.h>
+
+#include <cutils/multiuser.h>
+
+#include <string>
+
+__BEGIN_DECLS
+
+// NOTE: keep in sync with StorageManager
+static constexpr int FLAG_STORAGE_DE = 1 << 0;
+static constexpr int FLAG_STORAGE_CE = 1 << 1;
+// For 9.0 Ext4CryptPie.cpp
+static constexpr int STORAGE_FLAG_DE = 1;
+static constexpr int STORAGE_FLAG_CE = 2;
+
+static constexpr int NAMESPACE_LOCKSETTINGS = 103;
+
+namespace android {
+namespace keystore {
+    void copySqliteDb();
+    int Get_Password_Type(const userid_t user_id, std::string& filename);
+    bool Decrypt_DE();
+    bool Decrypt_User(const userid_t user_id, const std::string& Password);
+}
+}
+__END_DECLS
diff --git a/FsCrypt.cpp b/FsCrypt.cpp
index 09dcf81..e6e575e 100644
--- a/FsCrypt.cpp
+++ b/FsCrypt.cpp
@@ -60,6 +60,7 @@
 #include <android-base/stringprintf.h>
 #include <android-base/strings.h>
 #include <android-base/unique_fd.h>
+#include "fscrypt-common.h"
 
 using android::base::Basename;
 using android::base::Realpath;
@@ -97,11 +98,12 @@ const std::string systemwide_volume_key_dir =
 // Some users are ephemeral, don't try to wipe their keys from disk
 std::set<userid_t> s_ephemeral_users;
 
+}  // namespace
+
 // Map user ids to encryption policies
 std::map<userid_t, EncryptionPolicy> s_de_policies;
 std::map<userid_t, EncryptionPolicy> s_ce_policies;
-
-}  // namespace
+std::string de_key_raw_ref;
 
 // Returns KeyGeneration suitable for key as described in EncryptionOptions
 static KeyGeneration makeGen(const EncryptionOptions& options) {
@@ -201,6 +203,7 @@ static bool read_and_fixate_user_ce_key(userid_t user_id,
     auto const paths = get_ce_key_paths(directory_path);
     for (auto const ce_key_path : paths) {
         LOG(DEBUG) << "Trying user CE key " << ce_key_path;
+        LOG(INFO) <<"fscrypt::read_and_fixate_user_ce_key::retrieveKey";
         if (retrieveKey(ce_key_path, auth, ce_key)) {
             LOG(DEBUG) << "Successfully retrieved key";
             fixate_user_ce_key(directory_path, ce_key_path, paths);
@@ -233,6 +236,12 @@ static bool IsEmmcStorage(const std::string& blk_device) {
 
 // Retrieve the options to use for encryption policies on the /data filesystem.
 static bool get_data_file_encryption_options(EncryptionOptions* options) {
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
     auto entry = GetEntryForMountPoint(&fstab_default, DATA_MNT_POINT);
     if (entry == nullptr) {
         LOG(ERROR) << "No mount point entry for " << DATA_MNT_POINT;
@@ -307,7 +316,7 @@ static bool read_and_install_user_ce_key(userid_t user_id,
     EncryptionPolicy ce_policy;
     if (!install_storage_key(DATA_MNT_POINT, options, ce_key, &ce_policy)) return false;
     s_ce_policies[user_id] = ce_policy;
-    LOG(DEBUG) << "Installed ce key for user " << user_id;
+    LOG(INFO) << "Installed ce key for user " << user_id;
     return true;
 }
 
@@ -410,6 +419,7 @@ static bool load_all_de_keys() {
         userid_t user_id = std::stoi(entry->d_name);
         auto key_path = de_dir + "/" + entry->d_name;
         KeyBuffer de_key;
+        LOG(INFO) << "fscrypt::load_all_de_keys::retrieveKey";
         if (!retrieveKey(key_path, kEmptyAuthentication, &de_key)) return false;
         EncryptionPolicy de_policy;
         if (!install_storage_key(DATA_MNT_POINT, options, de_key, &de_policy)) return false;
@@ -418,7 +428,9 @@ static bool load_all_de_keys() {
             LOG(ERROR) << "DE policy for user" << user_id << " changed";
             return false;
         }
-        LOG(DEBUG) << "Installed de key for user " << user_id;
+        LOG(INFO) << "Installed de key for user " << user_id;
+        std::string user_prop = "twrp.user." + std::to_string(user_id) + ".decrypt";
+        property_set(user_prop.c_str(), "0");
     }
     // fscrypt:TODO: go through all DE directories, ensure that all user dirs have the
     // correct policy set on them, and that no rogue ones exist.
@@ -427,6 +439,7 @@ static bool load_all_de_keys() {
 
 // Attempt to reinstall CE keys for users that we think are unlocked.
 static bool try_reload_ce_keys() {
+    LOG(INFO) << "try_reload_ce_keys";
     for (const auto& it : s_ce_policies) {
         if (!android::vold::reloadKeyFromSessionKeyring(DATA_MNT_POINT, it.second)) {
             LOG(ERROR) << "Failed to load CE key from session keyring for user " << it.first;
@@ -459,6 +472,7 @@ bool fscrypt_initialize_systemwide_keys() {
     if (!android::vold::writeStringToFile(options_string, options_filename)) return false;
 
     std::string ref_filename = std::string(DATA_MNT_POINT) + fscrypt_key_ref;
+    de_key_raw_ref = device_policy.key_raw_ref;
     if (!android::vold::writeStringToFile(device_policy.key_raw_ref, ref_filename)) return false;
     LOG(INFO) << "Wrote system DE key reference to:" << ref_filename;
 
@@ -475,7 +489,7 @@ bool fscrypt_initialize_systemwide_keys() {
 }
 
 bool fscrypt_init_user0() {
-    LOG(DEBUG) << "fscrypt_init_user0";
+    LOG(INFO) << "fscrypt_init_user0";
     if (fscrypt_is_native()) {
         if (!prepare_dir(user_key_dir, 0700, AID_ROOT, AID_ROOT)) return false;
         if (!prepare_dir(user_key_dir + "/ce", 0700, AID_ROOT, AID_ROOT)) return false;
@@ -690,12 +704,12 @@ static bool fscrypt_rewrap_user_key(userid_t user_id, int serial,
     KeyBuffer ce_key;
     std::string ce_key_current_path = get_ce_key_current_path(directory_path);
     if (retrieveKey(ce_key_current_path, retrieve_auth, &ce_key)) {
-        LOG(DEBUG) << "Successfully retrieved key";
+        LOG(INFO) << "Successfully retrieved key";
         // TODO(147732812): Remove this once Locksettingservice is fixed.
         // Currently it calls fscrypt_clear_user_key_auth with a secret when lockscreen is
         // changed from swipe to none or vice-versa
     } else if (retrieveKey(ce_key_current_path, kEmptyAuthentication, &ce_key)) {
-        LOG(DEBUG) << "Successfully retrieved key with empty auth";
+        LOG(INFO) << "Successfully retrieved key with empty auth";
     } else {
         LOG(ERROR) << "Failed to retrieve key for user " << user_id;
         return false;
@@ -748,7 +762,7 @@ std::vector<int> fscrypt_get_unlocked_users() {
 
 // TODO: rename to 'install' for consistency, and take flags to know which keys to install
 bool fscrypt_unlock_user_key(userid_t user_id, int serial, const std::string& secret_hex) {
-    LOG(DEBUG) << "fscrypt_unlock_user_key " << user_id << " serial=" << serial;
+    LOG(INFO) << "fscrypt_unlock_user_key " << user_id << " serial=" << serial;
     if (fscrypt_is_native()) {
         if (s_ce_policies.count(user_id) != 0) {
             LOG(WARNING) << "Tried to unlock already-unlocked key for user " << user_id;
@@ -807,7 +821,7 @@ static bool prepare_subdirs(const std::string& action, const std::string& volume
 
 bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_id, int serial,
                                   int flags) {
-    LOG(DEBUG) << "fscrypt_prepare_user_storage for volume " << escape_empty(volume_uuid)
+    LOG(INFO) << "fscrypt_prepare_user_storage for volume " << escape_empty(volume_uuid)
                << ", user " << user_id << ", serial " << serial << ", flags " << flags;
 
     if (flags & android::os::IVold::STORAGE_FLAG_DE) {
@@ -850,7 +864,6 @@ bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_
             if (!EnsurePolicy(de_policy, user_de_path)) return false;
         }
     }
-
     if (flags & android::os::IVold::STORAGE_FLAG_CE) {
         // CE_n key
         auto system_ce_path = android::vold::BuildDataSystemCePath(user_id);
@@ -858,6 +871,7 @@ bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_
         auto vendor_ce_path = android::vold::BuildDataVendorCePath(user_id);
         auto media_ce_path = android::vold::BuildDataMediaCePath(volume_uuid, user_id);
         auto user_ce_path = android::vold::BuildDataUserCePath(volume_uuid, user_id);
+        LOG(INFO) << "fscrypt_prepare_user_storage";
 
         if (volume_uuid.empty()) {
             if (!prepare_dir(system_ce_path, 0770, AID_SYSTEM, AID_SYSTEM)) return false;
@@ -875,7 +889,6 @@ bool fscrypt_prepare_user_storage(const std::string& volume_uuid, userid_t user_
         }
 
         if (!prepare_dir(user_ce_path, 0771, AID_SYSTEM, AID_SYSTEM)) return false;
-
         if (fscrypt_is_native()) {
             EncryptionPolicy ce_policy;
             if (volume_uuid.empty()) {
@@ -1000,3 +1013,14 @@ bool fscrypt_destroy_volume_keys(const std::string& volume_uuid) {
     res &= destroy_volume_keys("/data/misc_de", volume_uuid);
     return res;
 }
+
+bool lookup_key_ref(const std::map<userid_t, android::fscrypt::EncryptionPolicy>& key_map, userid_t user_id,
+                           std::string* raw_ref) {
+    auto refi = key_map.find(user_id);
+    if (refi == key_map.end()) {
+        LOG(ERROR) << "Cannot find key for " << user_id;
+        return false;
+    }
+    *raw_ref = refi->second.key_raw_ref;
+    return true;
+}
\ No newline at end of file
diff --git a/FsCrypt.h b/FsCrypt.h
index 0517605..14a115a 100644
--- a/FsCrypt.h
+++ b/FsCrypt.h
@@ -40,3 +40,5 @@ bool fscrypt_destroy_user_storage(const std::string& volume_uuid, userid_t user_
 
 bool fscrypt_destroy_volume_keys(const std::string& volume_uuid);
 bool is_metadata_wrapped_key_supported();
+bool lookup_key_ref(const std::map<userid_t, android::fscrypt::EncryptionPolicy>& key_map, userid_t user_id,
+                           std::string* raw_ref);
diff --git a/HashPassword.cpp b/HashPassword.cpp
new file mode 100644
index 0000000..07ecb1f
--- /dev/null
+++ b/HashPassword.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2016 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * This computes the "secret" used by Android as one of the parameters
+ * to decrypt File Based Encryption. The secret is prefixed with
+ * "Android FBE credential hash" padded with 0s to 128 bytes then the
+ * user's password is appended to the end of the 128 bytes. This string
+ * is then hashed with sha512 and the sha512 value is then converted to
+ * hex with upper-case characters.
+ */
+
+#include <stdio.h>
+#include <string>
+#include <stdlib.h>
+#include <openssl/sha.h>
+#include <openssl/hmac.h>
+
+#include "HashPassword.h"
+
+#define PASS_PADDING_SIZE 128
+#define SHA512_HEX_SIZE SHA512_DIGEST_LENGTH * 2
+#define SHA256_HEX_SIZE SHA256_DIGEST_LENGTH * 2
+
+void* PersonalizedHashBinary(const char* prefix, const char* key, const size_t key_size) {
+	size_t size = PASS_PADDING_SIZE + key_size;
+	unsigned char* buffer = (unsigned char*)calloc(1, size);
+	if (!buffer) return NULL; // failed to malloc
+	memcpy((void*)buffer, (void*)prefix, strlen(prefix));
+	unsigned char* ptr = buffer + PASS_PADDING_SIZE;
+	memcpy((void*)ptr, key, key_size);
+	unsigned char hash[SHA512_DIGEST_LENGTH];
+	SHA512_CTX sha512;
+	SHA512_Init(&sha512);
+	SHA512_Update(&sha512, buffer, size);
+	SHA512_Final(hash, &sha512);
+	free(buffer);
+	void* ret = malloc(SHA512_DIGEST_LENGTH);
+	if (!ret) return NULL; // failed to malloc
+	memcpy(ret, (void*)&hash[0], SHA512_DIGEST_LENGTH);
+	return ret;
+}
+
+std::string PersonalizedHash(const char* prefix, const char* key, const size_t key_size) {
+	size_t size = PASS_PADDING_SIZE + key_size;
+	unsigned char* buffer = (unsigned char*)calloc(1, size);
+	if (!buffer) return ""; // failed to malloc
+	memcpy((void*)buffer, (void*)prefix, strlen(prefix));
+	unsigned char* ptr = buffer + PASS_PADDING_SIZE;
+	memcpy((void*)ptr, key, key_size);
+	unsigned char hash[SHA512_DIGEST_LENGTH];
+	SHA512_CTX sha512;
+	SHA512_Init(&sha512);
+	SHA512_Update(&sha512, buffer, size);
+	SHA512_Final(hash, &sha512);
+	int index = 0;
+	char hex_hash[SHA512_HEX_SIZE + 1];
+	for(index = 0; index < SHA512_DIGEST_LENGTH; index++)
+		sprintf(hex_hash + (index * 2), "%02X", hash[index]);
+	hex_hash[128] = 0;
+	std::string ret = hex_hash;
+	free(buffer);
+	return ret;
+}
+
+std::string PersonalizedHash(const char* prefix, const std::string& Password) {
+	return PersonalizedHash(prefix, Password.c_str(), Password.size());
+}
+
+std::string PersonalizedHashSP800(const char* label, const char* context, const char* key, const size_t key_size) {
+	HMAC_CTX ctx;
+	HMAC_CTX_init(&ctx);
+	HMAC_Init_ex(&ctx, key, key_size, EVP_sha256(), NULL);
+	unsigned int counter = 1;
+	endianswap(&counter);
+	HMAC_Update(&ctx, (const unsigned char*)&counter, 4);
+	HMAC_Update(&ctx, (const unsigned char*)label, strlen(label));
+	const unsigned char divider = 0;
+	HMAC_Update(&ctx, &divider, 1);
+	HMAC_Update(&ctx, (const unsigned char*)context, strlen(context));
+	unsigned int contextDisambiguation = strlen(context) * 8;
+	endianswap(&contextDisambiguation);
+	HMAC_Update(&ctx, (const unsigned char*)&contextDisambiguation, 4);
+	unsigned int finalValue = 256;
+	endianswap(&finalValue);
+	HMAC_Update(&ctx, (const unsigned char*)&finalValue, 4);
+
+	unsigned char output[SHA256_DIGEST_LENGTH];
+	unsigned int out_size = 0;
+	HMAC_Final(&ctx, output, &out_size);
+
+	int index = 0;
+	char hex_hash[SHA256_HEX_SIZE + 1];
+	for(index = 0; index < SHA256_DIGEST_LENGTH; index++)
+		sprintf(hex_hash + (index * 2), "%02x", output[index]);
+	hex_hash[SHA256_HEX_SIZE] = 0;
+	std::string ret = hex_hash;
+	return ret;
+}
+
+std::string HashPassword(const std::string& Password) {
+	const char* prefix = FBE_PERSONALIZATION;
+	return PersonalizedHash(prefix, Password);
+}
diff --git a/HashPassword.h b/HashPassword.h
new file mode 100644
index 0000000..73880b1
--- /dev/null
+++ b/HashPassword.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HASH_PASSWORD_H
+#define __HASH_PASSWORD_H
+
+#include <string>
+
+#define FBE_PERSONALIZATION "Android FBE credential hash"
+#define PERSONALISATION_WEAVER_KEY "weaver-key"
+#define PERSONALISATION_WEAVER_PASSWORD "weaver-pwd"
+#define PERSONALISATION_APPLICATION_ID "application-id"
+#define PERSONALIZATION_FBE_KEY "fbe-key"
+#define PERSONALIZATION_USER_GK_AUTH "user-gk-authentication"
+#define PERSONALISATION_SECDISCARDABLE "secdiscardable-transform"
+#define PERSONALISATION_CONTEXT "android-synthetic-password-personalization-context"
+
+void* PersonalizedHashBinary(const char* prefix, const char* key, const size_t key_size);
+
+std::string PersonalizedHash(const char* prefix, const char* key, const size_t key_size);
+std::string PersonalizedHash(const char* prefix, const std::string& Password);
+std::string PersonalizedHashSP800(const char* label, const char* context, const char* key, const size_t key_size);
+std::string HashPassword(const std::string& Password);
+
+template <class T>
+void endianswap(T *objp) {
+	unsigned char *memp = reinterpret_cast<unsigned char*>(objp);
+	std::reverse(memp, memp + sizeof(T));
+}
+
+#endif
diff --git a/KeyStorage.cpp b/KeyStorage.cpp
index c83c1eb..dadc37e 100644
--- a/KeyStorage.cpp
+++ b/KeyStorage.cpp
@@ -149,7 +149,7 @@ static bool generateKeyStorageKey(Keymaster& keymaster, const std::string& appId
                                 .GcmModeMinMacLen(GCM_MAC_BYTES * 8)
                                 .Authorization(km::TAG_APPLICATION_ID, appId)
                                 .Authorization(km::TAG_NO_AUTH_REQUIRED);
-    LOG(DEBUG) << "Generating \"key storage\" key";
+    LOG(INFO) << "Generating \"key storage\" key";
     return generateKeymasterKey(keymaster, paramBuilder, key);
 }
 
@@ -229,65 +229,65 @@ static std::vector<std::string> key_dirs_to_commit;
 
 // Replaces |dir|/keymaster_key_blob with |dir|/keymaster_key_blob_upgraded and
 // deletes the old key from Keymaster.
-static bool CommitUpgradedKey(Keymaster& keymaster, const std::string& dir) {
-    auto blob_file = dir + "/" + kFn_keymaster_key_blob;
-    auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
-
-    std::string blob;
-    if (!readFileToString(blob_file, &blob)) return false;
-
-    if (rename(upgraded_blob_file.c_str(), blob_file.c_str()) != 0) {
-        PLOG(ERROR) << "Failed to rename " << upgraded_blob_file << " to " << blob_file;
-        return false;
-    }
-    // Ensure that the rename is persisted before deleting the Keymaster key.
-    if (!FsyncDirectory(dir)) return false;
-
-    if (!keymaster || !keymaster.deleteKey(blob)) {
-        LOG(WARNING) << "Failed to delete old key " << blob_file
-                     << " from Keymaster; continuing anyway";
-        // Continue on, but the space in Keymaster used by the old key won't be freed.
-    }
-    return true;
-}
-
-static void DeferredCommitKeys() {
-    android::base::WaitForProperty("vold.checkpoint_committed", "1");
-    LOG(INFO) << "Committing upgraded keys";
-    Keymaster keymaster;
-    if (!keymaster) {
-        LOG(ERROR) << "Failed to open Keymaster; old keys won't be deleted from Keymaster";
+// static bool CommitUpgradedKey(Keymaster& keymaster, const std::string& dir) {
+//     auto blob_file = dir + "/" + kFn_keymaster_key_blob;
+//     auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
+
+//     std::string blob;
+//     if (!readFileToString(blob_file, &blob)) return false;
+
+//     if (rename(upgraded_blob_file.c_str(), blob_file.c_str()) != 0) {
+//         PLOG(ERROR) << "Failed to rename " << upgraded_blob_file << " to " << blob_file;
+//         return false;
+//     }
+//     // Ensure that the rename is persisted before deleting the Keymaster key.
+//     if (!FsyncDirectory(dir)) return false;
+
+//     if (!keymaster || !keymaster.deleteKey(blob)) {
+//         LOG(WARNING) << "Failed to delete old key " << blob_file
+//                      << " from Keymaster; continuing anyway";
+//         // Continue on, but the space in Keymaster used by the old key won't be freed.
+//     }
+//     return true;
+// }
+
+// static void DeferredCommitKeys() {
+//     android::base::WaitForProperty("vold.checkpoint_committed", "1");
+//     LOG(INFO) << "Committing upgraded keys";
+//     Keymaster keymaster;
+//     if (!keymaster) {
+//         LOG(ERROR) << "Failed to open Keymaster; old keys won't be deleted from Keymaster";
         // Continue on, but the space in Keymaster used by the old keys won't be freed.
-    }
-    std::lock_guard<std::mutex> lock(key_upgrade_lock);
-    for (auto& dir : key_dirs_to_commit) {
-        LOG(INFO) << "Committing upgraded key " << dir;
-        CommitUpgradedKey(keymaster, dir);
-    }
-    key_dirs_to_commit.clear();
-}
+//     }
+//     std::lock_guard<std::mutex> lock(key_upgrade_lock);
+//     for (auto& dir : key_dirs_to_commit) {
+//         LOG(INFO) << "Committing upgraded key " << dir;
+//         CommitUpgradedKey(keymaster, dir);
+//     }
+//     key_dirs_to_commit.clear();
+// }
 
 // Returns true if the Keymaster key in |dir| has already been upgraded and is
 // pending being committed.  Assumes that key_upgrade_lock is held.
-static bool IsKeyCommitPending(const std::string& dir) {
-    for (const auto& dir_to_commit : key_dirs_to_commit) {
-        if (IsSameFile(dir, dir_to_commit)) return true;
-    }
-    return false;
-}
+// static bool IsKeyCommitPending(const std::string& dir) {
+//     for (const auto& dir_to_commit : key_dirs_to_commit) {
+//         if (IsSameFile(dir, dir_to_commit)) return true;
+//     }
+//     return false;
+// }
 
 // Schedules the upgraded Keymaster key in |dir| to be committed later.
 // Assumes that key_upgrade_lock is held.
-static void ScheduleKeyCommit(const std::string& dir) {
-    if (key_dirs_to_commit.empty()) std::thread(DeferredCommitKeys).detach();
-    key_dirs_to_commit.push_back(dir);
-}
+// static void ScheduleKeyCommit(const std::string& dir) {
+//     if (key_dirs_to_commit.empty()) std::thread(DeferredCommitKeys).detach();
+//     key_dirs_to_commit.push_back(dir);
+// }
 
 static void CancelPendingKeyCommit(const std::string& dir) {
     std::lock_guard<std::mutex> lock(key_upgrade_lock);
     for (auto it = key_dirs_to_commit.begin(); it != key_dirs_to_commit.end(); it++) {
         if (IsSameFile(*it, dir)) {
-            LOG(DEBUG) << "Cancelling pending commit of upgraded key " << dir
+            LOG(INFO) << "Cancelling pending commit of upgraded key " << dir
                        << " because it is being destroyed";
             key_dirs_to_commit.erase(it);
             break;
@@ -316,23 +316,23 @@ static bool RenameKeyDir(const std::string& old_name, const std::string& new_nam
 // Deletes a leftover upgraded key, if present.  An upgraded key can be left
 // over if an update failed, or if we rebooted before committing the key in a
 // freak accident.  Either way, we can re-upgrade the key if we need to.
-static void DeleteUpgradedKey(Keymaster& keymaster, const std::string& path) {
-    if (pathExists(path)) {
-        LOG(DEBUG) << "Deleting leftover upgraded key " << path;
-        std::string blob;
-        if (!android::base::ReadFileToString(path, &blob)) {
-            LOG(WARNING) << "Failed to read leftover upgraded key " << path
-                         << "; continuing anyway";
-        } else if (!keymaster.deleteKey(blob)) {
-            LOG(WARNING) << "Failed to delete leftover upgraded key " << path
-                         << " from Keymaster; continuing anyway";
-        }
-        if (unlink(path.c_str()) != 0) {
-            LOG(WARNING) << "Failed to unlink leftover upgraded key " << path
-                         << "; continuing anyway";
-        }
-    }
-}
+// static void DeleteUpgradedKey(Keymaster& keymaster, const std::string& path) {
+//     if (pathExists(path)) {
+//         LOG(INFO) << "Deleting leftover upgraded key " << path;
+//         std::string blob;
+//         if (!android::base::ReadFileToString(path, &blob)) {
+//             LOG(WARNING) << "Failed to read leftover upgraded key " << path
+//                          << "; continuing anyway";
+//         } else if (!keymaster.deleteKey(blob)) {
+//             LOG(WARNING) << "Failed to delete leftover upgraded key " << path
+//                          << " from Keymaster; continuing anyway";
+//         }
+//         if (unlink(path.c_str()) != 0) {
+//             LOG(WARNING) << "Failed to unlink leftover upgraded key " << path
+//                          << "; continuing anyway";
+//         }
+//     }
+// }
 
 // Begins a Keymaster operation using the key stored in |dir|.
 static KeymasterOperation BeginKeymasterOp(Keymaster& keymaster, const std::string& dir,
@@ -343,44 +343,52 @@ static KeymasterOperation BeginKeymasterOp(Keymaster& keymaster, const std::stri
     inParams.append(opParams.begin(), opParams.end());
 
     auto blob_file = dir + "/" + kFn_keymaster_key_blob;
-    auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
+    PLOG(INFO) << "reading blob_file: " << blob_file;
+    std::string blob_dir(kFn_keymaster_key_blob);
+    std::string temp_dir = "/tmp/" + blob_dir + "/";
+    if (TEMP_FAILURE_RETRY(mkdir(temp_dir.c_str(), 0700)) == -1) {
+        PLOG(ERROR) << "key mkdir " << temp_dir;
+    }
 
+    auto upgraded_blob_file = temp_dir + kFn_keymaster_key_blob;
+    // auto upgraded_blob_file = dir + "/" + kFn_keymaster_key_blob_upgraded;
     std::lock_guard<std::mutex> lock(key_upgrade_lock);
 
     std::string blob;
-    bool already_upgraded = IsKeyCommitPending(dir);
-    if (already_upgraded) {
-        LOG(DEBUG)
-                << blob_file
-                << " was already upgraded and is waiting to be committed; using the upgraded blob";
-        if (!readFileToString(upgraded_blob_file, &blob)) return KeymasterOperation();
-    } else {
-        DeleteUpgradedKey(keymaster, upgraded_blob_file);
-        if (!readFileToString(blob_file, &blob)) return KeymasterOperation();
-    }
+    // bool already_upgraded = IsKeyCommitPending(dir);
+    // if (already_upgraded) {
+    //     LOG(INFO)
+    //             << blob_file
+    //             << " was already upgraded and is waiting to be committed; using the upgraded blob";
+    //     if (!readFileToString(upgraded_blob_file, &blob)) return KeymasterOperation();
+    // } else {
+        // DeleteUpgradedKey(keymaster, upgraded_blob_file);
+    if (!readFileToString(blob_file, &blob)) return KeymasterOperation();
+    // }
 
     auto opHandle = keymaster.begin(blob, inParams, outParams);
     if (!opHandle) return opHandle;
 
     // If key blob wasn't upgraded, nothing left to do.
-    if (!opHandle.getUpgradedBlob()) return opHandle;
+    // if (!opHandle.getUpgradedBlob()) return opHandle;
 
-    if (already_upgraded) {
-        LOG(ERROR) << "Unexpected case; already-upgraded key " << upgraded_blob_file
-                   << " still requires upgrade";
-        return KeymasterOperation();
-    }
+    // if (already_upgraded) {
+    //     LOG(ERROR) << "Unexpected case; already-upgraded key " << upgraded_blob_file
+    //                << " still requires upgrade";
+    //     return KeymasterOperation();
+    // }
     LOG(INFO) << "Upgrading key: " << blob_file;
+    
     if (!writeStringToFile(*opHandle.getUpgradedBlob(), upgraded_blob_file))
         return KeymasterOperation();
-    if (cp_needsCheckpoint()) {
-        LOG(INFO) << "Wrote upgraded key to " << upgraded_blob_file
-                  << "; delaying commit due to checkpoint";
-        ScheduleKeyCommit(dir);
-    } else {
-        if (!CommitUpgradedKey(keymaster, dir)) return KeymasterOperation();
-        LOG(INFO) << "Key upgraded: " << blob_file;
-    }
+    // if (cp_needsCheckpoint()) {
+    //     LOG(INFO) << "Wrote upgraded key to " << upgraded_blob_file
+    //               << "; delaying commit due to checkpoint";
+    //     ScheduleKeyCommit(dir);
+    // } else {
+    //     if (!CommitUpgradedKey(keymaster, dir)) return KeymasterOperation();
+    //     LOG(INFO) << "Key upgraded: " << blob_file;
+    // }
     return opHandle;
 }
 
@@ -614,7 +622,7 @@ bool storeKeyAtomically(const std::string& key_path, const std::string& tmp_path
         return false;
     }
     if (pathExists(tmp_path)) {
-        LOG(DEBUG) << "Already exists, destroying: " << tmp_path;
+        LOG(INFO) << "Already exists, destroying: " << tmp_path;
         destroyKey(tmp_path);  // May be partially created so ignore errors
     }
     if (!storeKey(tmp_path, auth, key)) return false;
@@ -624,11 +632,12 @@ bool storeKeyAtomically(const std::string& key_path, const std::string& tmp_path
         return false;
     }
     if (!FsyncParentDirectory(key_path)) return false;
-    LOG(DEBUG) << "Created key: " << key_path;
+    LOG(INFO) << "Created key: " << key_path;
     return true;
 }
 
 bool retrieveKey(const std::string& dir, const KeyAuthentication& auth, KeyBuffer* key) {
+    LOG(INFO) << "Retrieving key from keymaster";
     std::string version;
     if (!readFileToString(dir + "/" + kFn_version, &version)) return false;
     if (version != kCurrentVersion) {
@@ -660,7 +669,7 @@ static bool DeleteKeymasterKey(const std::string& blob_file) {
     if (!readFileToString(blob_file, &blob)) return false;
     Keymaster keymaster;
     if (!keymaster) return false;
-    LOG(DEBUG) << "Deleting key " << blob_file << " from Keymaster";
+    LOG(INFO) << "Deleting key " << blob_file << " from Keymaster";
     if (!keymaster.deleteKey(blob)) return false;
     return true;
 }
diff --git a/KeyStorage.h b/KeyStorage.h
index e318959..e379c0c 100644
--- a/KeyStorage.h
+++ b/KeyStorage.h
@@ -56,6 +56,9 @@ bool storeKeyAtomically(const std::string& key_path, const std::string& tmp_path
                         const KeyAuthentication& auth, const KeyBuffer& key);
 
 // Retrieve the key from the named directory.
+//
+// If the key is wrapped by a Keymaster key that requires an upgrade, then that
+// Keymaster key is upgraded.  
 bool retrieveKey(const std::string& dir, const KeyAuthentication& auth, KeyBuffer* key);
 
 // Securely destroy the key stored in the named directory and delete the directory.
diff --git a/KeyUtil.cpp b/KeyUtil.cpp
index 2074b18..9273564 100644
--- a/KeyUtil.cpp
+++ b/KeyUtil.cpp
@@ -57,10 +57,10 @@ bool generateStorageKey(const KeyGeneration& gen, KeyBuffer* key) {
             LOG(ERROR) << "Cannot generate a wrapped key " << gen.keysize << " bytes long";
             return false;
         }
-        LOG(DEBUG) << "Generating wrapped storage key";
+        LOG(INFO) << "Generating wrapped storage key";
         return generateWrappedStorageKey(key);
     } else {
-        LOG(DEBUG) << "Generating standard storage key";
+        LOG(INFO) << "Generating standard storage key";
         return randomKey(gen.keysize, key);
     }
 }
@@ -87,7 +87,7 @@ static bool isFsKeyringSupportedImpl() {
     if (errno != EFAULT) {
         PLOG(WARNING) << "Unexpected error from FS_IOC_ADD_ENCRYPTION_KEY";
     }
-    LOG(DEBUG) << "Detected support for FS_IOC_ADD_ENCRYPTION_KEY";
+    LOG(INFO) << "Detected support for FS_IOC_ADD_ENCRYPTION_KEY";
     android::base::SetProperty("ro.crypto.uses_fs_ioc_add_encryption_key", "true");
     return true;
 }
@@ -172,7 +172,7 @@ static bool installKeyLegacy(const KeyBuffer& key, const std::string& raw_ref) {
             PLOG(ERROR) << "Failed to insert key into keyring " << device_keyring;
             return false;
         }
-        LOG(DEBUG) << "Added key " << key_id << " (" << ref << ") to keyring " << device_keyring
+        LOG(INFO) << "Added key " << key_id << " (" << ref << ") to keyring " << device_keyring
                    << " in process " << getpid();
     }
     return true;
@@ -200,7 +200,7 @@ static bool installProvisioningKey(const KeyBuffer& key, const std::string& ref,
                     << " into session keyring";
         return false;
     }
-    LOG(DEBUG) << "Added fscrypt-provisioning key for " << ref << " to session keyring";
+    LOG(INFO) << "Added fscrypt-provisioning key for " << ref << " to session keyring";
     return true;
 }
 
@@ -312,7 +312,7 @@ bool installKey(const std::string& mountpoint, const EncryptionOptions& options,
                 std::string((char*)arg->key_spec.u.identifier, FSCRYPT_KEY_IDENTIFIER_SIZE);
     }
     std::string ref = keyrefstring(policy->key_raw_ref);
-    LOG(DEBUG) << "Installed fscrypt key with ref " << ref << " to " << mountpoint;
+    LOG(INFO) << "Installed fscrypt key with ref " << ref << " to " << mountpoint;
 
     if (!installProvisioningKey(key, ref, arg->key_spec)) return false;
     return true;
@@ -335,7 +335,7 @@ static bool evictKeyLegacy(const std::string& raw_ref) {
             PLOG(ERROR) << "Failed to unlink key with serial " << key_serial << " ref " << ref;
             success = false;
         } else {
-            LOG(DEBUG) << "Unlinked key with serial " << key_serial << " ref " << ref;
+            LOG(INFO) << "Unlinked key with serial " << key_serial << " ref " << ref;
         }
     }
     return success;
@@ -386,7 +386,7 @@ bool evictKey(const std::string& mountpoint, const EncryptionPolicy& policy) {
         return false;
     }
 
-    LOG(DEBUG) << "Evicted fscrypt key with ref " << ref << " from " << mountpoint;
+    LOG(INFO) << "Evicted fscrypt key with ref " << ref << " from " << mountpoint;
     if (arg.removal_status_flags & FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS) {
         // Should never happen because keys are only added/removed as root.
         LOG(ERROR) << "Unexpected case: key with ref " << ref << " is still added by other users!";
@@ -403,7 +403,7 @@ bool retrieveOrGenerateKey(const std::string& key_path, const std::string& tmp_p
                            const KeyAuthentication& key_authentication, const KeyGeneration& gen,
                            KeyBuffer* key) {
     if (pathExists(key_path)) {
-        LOG(DEBUG) << "Key exists, using: " << key_path;
+        LOG(INFO) << "Key exists, using: " << key_path;
         if (!retrieveKey(key_path, key_authentication, key)) return false;
     } else {
         if (!gen.allow_gen) {
@@ -431,7 +431,7 @@ bool reloadKeyFromSessionKeyring(const std::string& mountpoint, const Encryption
         return false;
     }
 
-    LOG(DEBUG) << "Installing fscrypt-provisioning key for " << ref << " back into " << mountpoint
+    LOG(INFO) << "Installing fscrypt-provisioning key for " << ref << " back into " << mountpoint
                << " fs-keyring";
 
     struct fscrypt_add_key_arg arg;
diff --git a/Keymaster.cpp b/Keymaster.cpp
index 2314550..5aac9ba 100644
--- a/Keymaster.cpp
+++ b/Keymaster.cpp
@@ -199,7 +199,7 @@ KeymasterOperation Keymaster::begin(const std::string& key, const km::Authorizat
             std::optional<std::vector<uint8_t>>(std::vector<uint8_t>(key.begin(), key.end()));
 
     ks2::CreateOperationResponse cor;
-    auto rc = securityLevel->createOperation(keyDesc, inParams.vector_data(), true, &cor);
+    auto rc = securityLevel->createOperation(keyDesc, inParams.vector_data(), false, &cor);
     if (logKeystore2ExceptionIfPresent(rc, "createOperation")) {
         if (rc.getExceptionCode() == EX_SERVICE_SPECIFIC)
             return KeymasterOperation((km::ErrorCode)rc.getServiceSpecificError());
diff --git a/KeystoreInfo.cpp b/KeystoreInfo.cpp
new file mode 100755
index 0000000..9b13387
--- /dev/null
+++ b/KeystoreInfo.cpp
@@ -0,0 +1,79 @@
+/*
+		Copyright 2013 to 2022 TeamWin
+		TWRP is free software: you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation, either version 3 of the License, or
+		(at your option) any later version.
+
+		TWRP is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with TWRP.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <string>
+#include <sstream>
+#include <algorithm>
+#include <string>
+#include <sqlite3.h>
+#include "KeystoreInfo.hpp"
+
+std::string KeystoreInfo::uint2hex(int64_t num) {
+	uint64_t temp = num;
+	std::string s = "";
+	while (temp) {
+		int a = temp % 16;
+		if (a <= 9)
+			s += (48 + a);
+		else
+			s += (87 + a);
+		temp = temp / 16;
+	}
+	std::reverse(s.begin(), s.end());
+	return s;
+}
+
+std::string KeystoreInfo::getHandle(const userid_t user_id) {
+	int rc = 0;
+   	sqlite3 *db;
+	sqlite3_stmt *stmt;
+	char *err_msg = 0;
+  	
+	rc = sqlite3_open("/data/system/locksettings.db", &db);
+	if (rc) {
+		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
+		return "";
+	}
+	std::string sql = "SELECT * FROM locksettings WHERE name = 'sp-handle' AND user = " + std::to_string(user_id);
+	rc = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, NULL);
+	if (rc != SQLITE_OK)
+		return "";
+	int64_t value = 0;
+	while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
+		value = sqlite3_column_int64(stmt, 3);
+	}
+	if (rc != SQLITE_DONE) {
+		fprintf(stderr, "error: %s\n", sqlite3_errmsg(db));
+		return "";
+	}
+	sqlite3_finalize(stmt);
+	sqlite3_close(db);
+	return uint2hex(value);
+}
+
+std::string KeystoreInfo::getAlias(std::string handle) {
+	std::string alias(SYNTHETIC_PASSWORD_KEY_PREFIX);
+	alias = alias + handle;
+	return alias;
+}
diff --git a/KeystoreInfo.hpp b/KeystoreInfo.hpp
new file mode 100755
index 0000000..a6a5850
--- /dev/null
+++ b/KeystoreInfo.hpp
@@ -0,0 +1,32 @@
+/*
+		TWRP is free software: you can redistribute it and/or modify
+		it under the terms of the GNU General Public License as published by
+		the Free Software Foundation, either version 3 of the License, or
+		(at your option) any later version.
+
+		TWRP is distributed in the hope that it will be useful,
+		but WITHOUT ANY WARRANTY; without even the implied warranty of
+		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+		GNU General Public License for more details.
+
+		You should have received a copy of the GNU General Public License
+		along with TWRP.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <string>
+#include <cutils/multiuser.h>
+
+#ifndef __KEYSTOREINFO_H
+#define __KEYSTOREINFO_H
+
+#define SYNTHETIC_PASSWORD_KEY_PREFIX "synthetic_password_"
+class KeystoreInfo {
+public:
+std::string getHandle(const userid_t user_id);
+std::string getAlias(std::string handle);
+
+private:
+std::string uint2hex(int64_t num);
+};
+
+#endif //__KEYSTOREINFO_H
diff --git a/MetadataCrypt.cpp b/MetadataCrypt.cpp
index e68e1ef..3e89063 100644
--- a/MetadataCrypt.cpp
+++ b/MetadataCrypt.cpp
@@ -88,6 +88,12 @@ static bool mount_via_fs_mgr(const char* mount_point, const char* blk_device) {
         PLOG(ERROR) << "Failed to setexeccon";
         return false;
     }
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
     auto mount_rc = fs_mgr_do_mount(&fstab_default, const_cast<char*>(mount_point),
                                     const_cast<char*>(blk_device), nullptr,
                                     android::vold::cp_needsCheckpoint(), true);
@@ -99,7 +105,7 @@ static bool mount_via_fs_mgr(const char* mount_point, const char* blk_device) {
         LOG(ERROR) << "fs_mgr_do_mount failed with rc " << mount_rc;
         return false;
     }
-    LOG(DEBUG) << "Mounted " << mount_point;
+    LOG(INFO) << "Mounted " << mount_point;
     return true;
 }
 
@@ -111,7 +117,7 @@ static bool read_key(const std::string& metadata_key_dir, const KeyGeneration& g
     }
     std::string sKey;
     auto dir = metadata_key_dir + "/key";
-    LOG(DEBUG) << "metadata_key_dir/key: " << dir;
+    LOG(INFO) << "metadata_key_dir/key: " << dir;
     if (!MkdirsSync(dir, 0700)) return false;
     if (!pathExists(dir)) {
         auto delete_all = android::base::GetBoolProperty(
@@ -120,7 +126,7 @@ static bool read_key(const std::string& metadata_key_dir, const KeyGeneration& g
             LOG(INFO) << "Metadata key does not exist, calling deleteAllKeys";
             Keymaster::deleteAllKeys();
         } else {
-            LOG(DEBUG) << "Metadata key does not exist but "
+            LOG(INFO) << "Metadata key does not exist but "
                           "ro.crypto.metadata_init_delete_all_keys.enabled is false";
         }
     }
@@ -215,15 +221,22 @@ static bool parse_options(const std::string& options_string, CryptoOptions* opti
 bool fscrypt_mount_metadata_encrypted(const std::string& blk_device, const std::string& mount_point,
                                       bool needs_encrypt, bool should_format,
                                       const std::string& fs_type) {
-    LOG(DEBUG) << "fscrypt_mount_metadata_encrypted: " << mount_point
+    LOG(INFO) << "fscrypt_mount_metadata_encrypted: " << mount_point
                << " encrypt: " << needs_encrypt << " format: " << should_format << " with "
                << fs_type;
     auto encrypted_state = android::base::GetProperty("ro.crypto.state", "");
     if (encrypted_state != "" && encrypted_state != "encrypted") {
-        LOG(DEBUG) << "fscrypt_enable_crypto got unexpected starting state: " << encrypted_state;
+        LOG(INFO) << "fscrypt_enable_crypto got unexpected starting state: " << encrypted_state;
         return false;
     }
 
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
+
     auto data_rec = GetEntryForMountPoint(&fstab_default, mount_point);
     if (!data_rec) {
         LOG(ERROR) << "Failed to get data_rec for " << mount_point;
@@ -278,15 +291,16 @@ bool fscrypt_mount_metadata_encrypted(const std::string& blk_device, const std::
                 LOG(ERROR) << "Unknown filesystem type: " << fs_type;
                 return false;
             }
-            LOG(DEBUG) << "Format (err=" << error << ") " << crypto_blkdev << " on " << mount_point;
+            LOG(INFO) << "Format (err=" << error << ") " << crypto_blkdev << " on " << mount_point;
             if (error != 0) return false;
         } else {
             if (!encrypt_inplace(crypto_blkdev, blk_device, nr_sec, false)) return false;
         }
     }
 
-    LOG(DEBUG) << "Mounting metadata-encrypted filesystem:" << mount_point;
+    LOG(INFO) << "Mounting metadata-encrypted filesystem:" << mount_point;
     mount_via_fs_mgr(mount_point.c_str(), crypto_blkdev.c_str());
+    android::base::SetProperty("ro.crypto.fs_crypto_blkdev", crypto_blkdev);
 
     // Record that there's at least one fstab entry with metadata encryption
     if (!android::base::SetProperty("ro.crypto.metadata.enabled", "true")) {
@@ -309,7 +323,7 @@ bool defaultkey_volume_keygen(KeyGeneration* gen) {
 
 bool defaultkey_setup_ext_volume(const std::string& label, const std::string& blk_device,
                                  const KeyBuffer& key, std::string* out_crypto_blkdev) {
-    LOG(DEBUG) << "defaultkey_setup_ext_volume: " << label << " " << blk_device;
+    LOG(INFO) << "defaultkey_setup_ext_volume: " << label << " " << blk_device;
 
     CryptoOptions options;
     if (!get_volume_options(&options)) return false;
@@ -318,17 +332,23 @@ bool defaultkey_setup_ext_volume(const std::string& label, const std::string& bl
 }
 
 bool destroy_dsu_metadata_key(const std::string& dsu_slot) {
-    LOG(DEBUG) << "destroy_dsu_metadata_key: " << dsu_slot;
+    LOG(INFO) << "destroy_dsu_metadata_key: " << dsu_slot;
 
     const auto dsu_metadata_key_dir = android::gsi::GetDsuMetadataKeyDir(dsu_slot);
     if (!pathExists(dsu_metadata_key_dir)) {
-        LOG(DEBUG) << "DSU metadata_key_dir doesn't exist, nothing to remove: "
+        LOG(INFO) << "DSU metadata_key_dir doesn't exist, nothing to remove: "
                    << dsu_metadata_key_dir;
         return true;
     }
 
     // Ensure that the DSU key directory is different from the host OS'.
     // Under normal circumstances, this should never happen, but handle it just in case.
+    if (fstab_default.empty()) {
+        if (!ReadDefaultFstab(&fstab_default)) {
+            PLOG(ERROR) << "Failed to open default fstab";
+            return false;
+        }
+    }
     if (auto data_rec = GetEntryForMountPoint(&fstab_default, "/data")) {
         if (dsu_metadata_key_dir == data_rec->metadata_key_dir) {
             LOG(ERROR) << "DSU metadata_key_dir is same as host OS: " << dsu_metadata_key_dir;
@@ -340,7 +360,7 @@ bool destroy_dsu_metadata_key(const std::string& dsu_slot) {
     for (auto suffix : {"/key", "/tmp"}) {
         const auto key_path = dsu_metadata_key_dir + suffix;
         if (pathExists(key_path)) {
-            LOG(DEBUG) << "Destroy key: " << key_path;
+            LOG(INFO) << "Destroy key: " << key_path;
             if (!android::vold::destroyKey(key_path)) {
                 LOG(ERROR) << "Failed to destroyKey(): " << key_path;
                 ok = false;
@@ -351,7 +371,7 @@ bool destroy_dsu_metadata_key(const std::string& dsu_slot) {
         return false;
     }
 
-    LOG(DEBUG) << "Remove DSU metadata_key_dir: " << dsu_metadata_key_dir;
+    LOG(INFO) << "Remove DSU metadata_key_dir: " << dsu_metadata_key_dir;
     // DeleteDirContentsAndDir() already logged any error, so don't log repeatedly.
     return android::vold::DeleteDirContentsAndDir(dsu_metadata_key_dir) == android::OK;
 }
diff --git a/Utils.cpp b/Utils.cpp
index 2144a3a..a33a16e 100644
--- a/Utils.cpp
+++ b/Utils.cpp
@@ -88,6 +88,7 @@ static const char* kAppObbDir = "/Android/obb/";
 
 static const char* kMediaProviderCtx = "u:r:mediaprovider:";
 static const char* kMediaProviderAppCtx = "u:r:mediaprovider_app:";
+struct selabel_handle* sehandle;
 
 // Lock used to protect process-level SELinux changes from racing with each
 // other between multiple threads.
diff --git a/Weaver1.cpp b/Weaver1.cpp
new file mode 100644
index 0000000..ea357ed
--- /dev/null
+++ b/Weaver1.cpp
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2017 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* To the best of my knowledge there is no native implementation for
+ * Weaver so I made this by looking at the IWeaver.h file that gets
+ * compiled by the build system. I took the information from this header
+ * file and looked at keymaster source to get an idea of the proper way
+ * to write the functions.
+ */
+
+#include "Weaver1.h"
+
+//#include <android-base/logging.h>
+//#include <keystore/keymaster_tags.h>
+//#include <keystore/authorization_set.h>
+//#include <keystore/keystore_hidl_support.h>
+
+#include <android/hardware/weaver/1.0/IWeaver.h>
+
+#include <iostream>
+#define ERROR 1
+#define LOG(x) std::cout
+
+using namespace android::hardware::weaver;
+using android::hardware::hidl_string;
+using ::android::hardware::weaver::V1_0::IWeaver;
+using ::android::hardware::weaver::V1_0::WeaverConfig;
+using ::android::hardware::weaver::V1_0::WeaverReadStatus;
+using ::android::hardware::weaver::V1_0::WeaverReadResponse;
+using ::android::hardware::weaver::V1_0::WeaverStatus;
+using ::android::hardware::Return;
+using ::android::sp;
+
+namespace android {
+namespace vold {
+
+Weaver::Weaver() {
+	mDevice = ::android::hardware::weaver::V1_0::IWeaver::getService();
+	GottenConfig = false;
+}
+
+bool Weaver::GetConfig() {
+	if (GottenConfig)
+		return true;
+
+	WeaverStatus status;
+	WeaverConfig cfg;
+
+	bool callbackCalled = false;
+	auto ret = mDevice->getConfig([&](WeaverStatus s, WeaverConfig c) {
+		callbackCalled = true;
+		status = s;
+		cfg = c;
+	});
+	if (ret.isOk() && callbackCalled && status == WeaverStatus::OK) {
+		config = cfg;
+		GottenConfig = true;
+		return true;
+	}
+	return false;
+}
+
+bool Weaver::GetSlots(uint32_t* slots) {
+	if (!GetConfig())
+		return false;
+	*slots = config.slots;
+	return true;
+}
+
+bool Weaver::GetKeySize(uint32_t* keySize) {
+	if (!GetConfig())
+		return false;
+	*keySize = config.keySize;
+	return true;
+}
+
+bool Weaver::GetValueSize(uint32_t* valueSize) {
+	if (!GetConfig())
+		return false;
+	*valueSize = config.valueSize;
+	return true;
+}
+
+// TODO: we should return more information about the status including time delays before the next retry
+bool Weaver::WeaverVerify(const uint32_t slot, const void* weaver_key, std::vector<uint8_t>* payload) {
+	bool callbackCalled = false;
+	WeaverReadStatus status;
+	std::vector<uint8_t> readValue;
+	uint32_t timeout;
+	uint32_t keySize;
+	if (!GetKeySize(&keySize))
+		return false;
+	std::vector<uint8_t> key;
+	key.resize(keySize);
+	uint32_t index = 0;
+	unsigned char* ptr = (unsigned char*)weaver_key;
+	for (index = 0; index < keySize; index++) {
+		key[index] = *ptr;
+		ptr++;
+	}
+	const auto readRet = mDevice->read(slot, key, [&](WeaverReadStatus s, WeaverReadResponse r) {
+		callbackCalled = true;
+		status = s;
+		readValue = r.value;
+		timeout = r.timeout;
+	});
+	if (readRet.isOk() && callbackCalled && status == WeaverReadStatus::OK && timeout == 0) {
+		*payload = readValue;
+		return true;
+	}
+	return false;
+}
+
+}  // namespace vold
+}  // namespace android
diff --git a/Weaver1.h b/Weaver1.h
new file mode 100644
index 0000000..22f401e
--- /dev/null
+++ b/Weaver1.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2017 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* To the best of my knowledge there is no native implementation for
+ * Weaver so I made this by looking at the IWeaver.h file that gets
+ * compiled by the build system. I took the information from this header
+ * file and looked at keymaster source to get an idea of the proper way
+ * to write the functions.
+ */
+
+#ifndef TWRP_WEAVER_H
+#define TWRP_WEAVER_H
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include <android/hardware/weaver/1.0/IWeaver.h>
+#include "Utils.h"
+
+namespace android {
+namespace vold {
+using ::android::hardware::weaver::V1_0::IWeaver;
+
+// Wrapper for a Weaver device
+class Weaver {
+	public:
+		Weaver();
+		// false if we failed to open the weaver device.
+		explicit operator bool() { return mDevice.get() != nullptr; }
+
+		bool GetSlots(uint32_t* slots);
+		bool GetKeySize(uint32_t* keySize);
+		bool GetValueSize(uint32_t* valueSize);
+		// TODO: we should return more information about the status including time delays before the next retry
+		bool WeaverVerify(const uint32_t slot, const void* weaver_key, std::vector<uint8_t>* payload);
+
+	private:
+		sp<hardware::weaver::V1_0::IWeaver> mDevice;
+		hardware::weaver::V1_0::WeaverConfig config;
+		bool GottenConfig;
+
+		bool GetConfig();
+
+		DISALLOW_COPY_AND_ASSIGN(Weaver);
+};
+
+}  // namespace vold
+}  // namespace android
+
+#endif
diff --git a/cryptfs.cpp b/cryptfs.cpp
index 5fa49fe..623d628 100644
--- a/cryptfs.cpp
+++ b/cryptfs.cpp
@@ -1558,7 +1558,7 @@ static int create_crypto_blk_dev(struct crypt_mnt_ftr* crypt_ftr, const unsigned
     return 0;
 }
 
-static int delete_crypto_blk_dev(const std::string& name) {
+int delete_crypto_blk_dev(const std::string& name) {
     bool ret;
     auto& dm = DeviceMapper::Instance();
     // TODO(b/149396179) there appears to be a race somewhere in the system where trying
diff --git a/cryptfs.h b/cryptfs.h
index 3ce0bd4..2b375a6 100644
--- a/cryptfs.h
+++ b/cryptfs.h
@@ -80,6 +80,7 @@ int cryptfs_getfield(const char* fieldname, char* value, int len);
 int cryptfs_setfield(const char* fieldname, const char* value);
 int cryptfs_mount_default_encrypted(void);
 int cryptfs_get_password_type(void);
+int delete_crypto_blk_dev(const std::string& name);
 const char* cryptfs_get_password(void);
 void cryptfs_clear_password(void);
 int cryptfs_isConvertibleToFBE(void);
diff --git a/fscrypt-common.h b/fscrypt-common.h
new file mode 100755
index 0000000..fde5837
--- /dev/null
+++ b/fscrypt-common.h
@@ -0,0 +1,9 @@
+#include <map>
+#include <string>
+
+#define CRYPT_TYPE_DEFAULT  1
+
+// Store main DE/CE policy
+extern std::map<userid_t, android::fscrypt::EncryptionPolicy> s_de_policies;
+extern std::map<userid_t, android::fscrypt::EncryptionPolicy> s_ce_policies;
+extern std::string de_key_raw_ref;
diff --git a/fscrypt_policy.cpp b/fscrypt_policy.cpp
new file mode 100755
index 0000000..e915355
--- /dev/null
+++ b/fscrypt_policy.cpp
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <array>
+
+#include <asm/ioctl.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/fs.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <cutils/properties.h>
+#include <logwrap/logwrap.h>
+#include <utils/misc.h>
+#include <fscrypt/fscrypt.h>
+#include "KeyUtil.h"
+
+#include "fscrypt_policy.h"
+
+static int encryption_mode = FS_ENCRYPTION_MODE_PRIVATE;
+
+bool fscrypt_is_native() {
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.crypto.type", value, "none");
+    return !strcmp(value, "file");
+}
+
+extern "C" void bytes_to_hex(const uint8_t *bytes, size_t num_bytes, char *hex) {
+  for (size_t i = 0; i < num_bytes; i++) {
+    sprintf(&hex[2 * i], "%02x", bytes[i]);
+  }
+}
+
+extern "C" bool fscrypt_set_mode() {
+    const char* mode_file = "/data/unencrypted/mode";
+    struct stat st;
+    if (stat(mode_file, &st) != 0 || st.st_size <= 0) {
+        printf("Invalid encryption mode file %s\n", mode_file);
+        return false;
+    }
+    ssize_t mode_size = st.st_size;
+    char contents_encryption_mode[mode_size + 1];
+    memset((void*)contents_encryption_mode, 0, mode_size + 1);
+    int fd = open(mode_file, O_RDONLY | O_CLOEXEC);
+    if (fd < 0) {
+        printf("error opening '%s': %s\n", mode_file, strerror(errno));
+        return false;
+    }
+    if (read(fd, contents_encryption_mode, mode_size) != mode_size) {
+        printf("read error on '%s': %s\n", mode_file, strerror(errno));
+        close(fd);
+        return false;
+    }
+    close(fd);
+
+    std::string contents_encryption_mode_string = std::string(contents_encryption_mode);
+    int pos = contents_encryption_mode_string.find(":");
+    LOG(INFO) << "contents_encryption_mode_string: " << contents_encryption_mode_string.substr(0, pos);
+
+    if (contents_encryption_mode_string.substr(0, pos) == "software") {
+        encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;
+    } else if (contents_encryption_mode_string.substr(0, pos) == "ice") {
+        encryption_mode = FS_ENCRYPTION_MODE_PRIVATE;
+    } else {
+        printf("Invalid encryption mode '%s'\n", contents_encryption_mode);
+        return false;
+    }
+
+    printf("set encryption mode to %i\n", encryption_mode);
+    return true;
+}
+
+#ifdef USE_FSCRYPT_POLICY_V1
+extern "C" bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v1 *fep) {
+#else
+extern "C" bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v2 *fep) {
+#endif
+    int fd = open(directory, O_DIRECTORY | O_NOFOLLOW | O_CLOEXEC);
+    if (fd == -1) {
+        printf("failed to open %s\n", directory);
+        PLOG(ERROR) << "Failed to open directory " << directory;
+        return false;
+    }
+    if (android::vold::isFsKeyringSupported()) {
+        if (ioctl(fd, FS_IOC_SET_ENCRYPTION_POLICY, fep)) {
+            PLOG(ERROR) << "Failed to set encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+    } else {
+        if (ioctl(fd, FS_IOC_SET_ENCRYPTION_POLICY, fep)) {
+            PLOG(ERROR) << "Failed to set encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+    }
+    close(fd);
+    return true;
+}
+
+#ifdef USE_FSCRYPT_POLICY_V1
+extern "C" bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v1 *fep) {
+#else
+extern "C" bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v2 *fep) {
+#endif
+    int fd = open(directory, O_DIRECTORY | O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
+    if (fd == -1) {
+        PLOG(ERROR) << "Failed to open directory " << directory;
+        return false;
+    }
+#ifdef USE_FSCRYPT_POLICY_V1
+    memset(fep, 0, sizeof(fscrypt_policy_v1));
+#else
+    memset(fep, 0, sizeof(fscrypt_policy_v2));
+#endif
+    struct fscrypt_get_policy_ex_arg ex_policy = {0};
+
+    if (android::vold::isFsKeyringSupported()) {
+        ex_policy.policy_size = sizeof(ex_policy.policy);
+        if (ioctl(fd, FS_IOC_GET_ENCRYPTION_POLICY_EX, &ex_policy) != 0) {
+            PLOG(ERROR) << "Failed to get encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+#ifdef USE_FSCRYPT_POLICY_V1
+        memcpy(fep, &ex_policy.policy.v1, sizeof(ex_policy.policy.v1));
+#else
+        memcpy(fep, &ex_policy.policy.v2, sizeof(ex_policy.policy.v2));
+#endif
+    } else {
+        if (ioctl(fd, FS_IOC_GET_ENCRYPTION_POLICY, &ex_policy.policy.v1) != 0) {
+            PLOG(ERROR) << "Failed to get encryption policy for " << directory;
+            close(fd);
+            return false;
+        }
+        memcpy(fep, &ex_policy.policy.v1, sizeof(ex_policy.policy.v1));
+    }
+    close(fd);
+    return true;
+}
diff --git a/fscrypt_policy.h b/fscrypt_policy.h
new file mode 100755
index 0000000..5714790
--- /dev/null
+++ b/fscrypt_policy.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _FS_CRYPT_H_
+#define _FS_CRYPT_H_
+
+#include <sys/cdefs.h>
+#include <stdbool.h>
+#include <cutils/multiuser.h>
+#include <linux/fs.h>
+
+__BEGIN_DECLS
+
+#define FS_KEY_DESCRIPTOR_SIZE_HEX (2 * FS_KEY_DESCRIPTOR_SIZE + 1)
+#define FSCRYPT_KEY_IDENTIFIER_HEX_SIZE ((2 * FSCRYPT_KEY_IDENTIFIER_SIZE) + 1)
+
+#ifdef USE_FSCRYPT_POLICY_V1
+#define USER_CE_FSCRYPT_POLICY           "0CE"
+#define USER_DE_FSCRYPT_POLICY           "0DE"
+#define SYSTEM_DE_FSCRYPT_POLICY         "0DK"
+#else
+#define USER_CE_FSCRYPT_POLICY           "2CE"
+#define USER_DE_FSCRYPT_POLICY           "2DE"
+#define SYSTEM_DE_FSCRYPT_POLICY         "2DK"
+#endif
+
+#define FSCRYPT_V1                        "0"
+#define FSCRYPT_V2                        "2"
+#define SYSTEM_DE_KEY                     "DK"
+#define USER_CE_KEY                       "C"
+#define USER_DE_KEY                       "D"
+
+/* modes not supported by upstream kernel, so not in <linux/fs.h> */
+#define FS_ENCRYPTION_MODE_AES_256_HEH      126
+#define FS_ENCRYPTION_MODE_PRIVATE          127
+
+/* new definition, not yet in Bionic's <linux/fs.h> */
+#ifndef FS_ENCRYPTION_MODE_ADIANTUM
+#define FS_ENCRYPTION_MODE_ADIANTUM         9
+#endif
+
+/* new definition, not yet in Bionic's <linux/fs.h> */
+#ifndef FS_POLICY_FLAG_DIRECT_KEY
+#define FS_POLICY_FLAG_DIRECT_KEY           0x4
+#endif
+
+#define HEX_LOOKUP "0123456789abcdef"
+
+bool fscrypt_set_mode();
+
+#ifdef USE_FSCRYPT_POLICY_V1
+bool lookup_ref_key(struct fscrypt_policy_v1 *fep, uint8_t* policy_type);
+#else
+bool lookup_ref_key(struct fscrypt_policy_v2 *fep, uint8_t* policy_type);
+#endif
+
+bool lookup_ref_tar(const uint8_t *policy_type, uint8_t *policy);
+
+#ifdef USE_FSCRYPT_POLICY_V1
+bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v1  *fep);
+#else
+bool fscrypt_policy_get_struct(const char *directory, struct fscrypt_policy_v2  *fep);
+#endif
+
+#ifdef USE_FSCRYPT_POLICY_V1
+bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v1  *fep);
+#else
+bool fscrypt_policy_set_struct(const char *directory, const struct fscrypt_policy_v2  *fep);
+#endif
+
+void bytes_to_hex(const uint8_t *bytes, size_t num_bytes, char *hex);
+__END_DECLS
+
+#endif // _FS_CRYPT_H_
diff --git a/fscryptpolicyget.cpp b/fscryptpolicyget.cpp
new file mode 100755
index 0000000..189a428
--- /dev/null
+++ b/fscryptpolicyget.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 Team Win Recovery Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "fscrypt_policy.h"
+#include "fscrypt/fscrypt.h"
+
+int main(int argc, char *argv[]) {
+	if (argc != 2) {
+		printf("Must specify a path\n");
+		return -1;
+	} else  {
+#ifdef USE_FSCRYPT_POLICY_V1
+		fscrypt_policy_v1 fep;
+#else
+		fscrypt_policy_v2 fep;
+#endif
+		if (fscrypt_policy_get_struct(argv[1], &fep)) {
+#ifdef USE_FSCRYPT_POLICY_V1
+			char policy_hex[FS_KEY_DESCRIPTOR_SIZE_HEX];
+			bytes_to_hex(fep.master_key_descriptor, FS_KEY_DESCRIPTOR_SIZE, policy_hex);
+#else
+			char policy_hex[FSCRYPT_KEY_IDENTIFIER_HEX_SIZE];
+			bytes_to_hex(fep.master_key_identifier, FSCRYPT_KEY_IDENTIFIER_SIZE, policy_hex);
+#endif
+			printf("%s\n", policy_hex);
+		} else {
+			printf("No policy set\n");
+		}
+	}
+	return 0;
+}
